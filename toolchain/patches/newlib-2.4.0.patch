diff -rupN old/config.sub new/config.sub
--- old/config.sub	2016-03-29 16:33:42.000000000 -0500
+++ new/config.sub	2016-04-29 09:21:24.083384132 -0500
@@ -1391,7 +1391,7 @@ case $os in
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
+	      | -uxpv* | -beos* | -mpeix* | -toyos* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
diff -rupN old/newlib/configure.host new/newlib/configure.host
--- old/newlib/configure.host	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/configure.host	2016-04-29 09:21:24.083384132 -0500
@@ -448,6 +448,10 @@ case "${host}" in
   h8500-*-elf*)
 	sys_dir=h8500hms
 	;;
+  i[34567]86-*-toyos*)
+	sys_dir=toyos
+	posix_dir=posix
+	;;
   i[34567]86-*-rdos*)
 	sys_dir=rdos
 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
@@ -567,6 +571,9 @@ esac
 # THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
 
 case "${host}" in
+  *-*-toyos)
+	newlib_cflags="${newlib_cflags} -fPIC -DSIGNAL_PROVIDED -DMISSING_SYSCALL_NAMES -DMALLOC_PROVIDED"
+	;;
   *-*-cygwin*)
 	test -z "$cygwin_srcdir" && cygwin_srcdir=`cd ${srcdir}/../winsup/cygwin; pwd`
 	export cygwin_srcdir
diff -rupN old/newlib/configure.host.orig new/newlib/configure.host.orig
--- old/newlib/configure.host.orig	1969-12-31 18:00:00.000000000 -0600
+++ new/newlib/configure.host.orig	2016-04-29 09:21:24.087384166 -0500
@@ -0,0 +1,892 @@
+# configure.host
+
+# This shell script handles all host based configuration for newlib.
+# It sets various shell variables based on the the host and the
+# configuration options.  You can modify this shell script without
+# needing to rerun autoconf.
+
+# This shell script should be invoked as
+#   . configure.host
+# If it encounters an error, it will exit with a message.
+
+# FIXME: This script is too complicated.  It does things in too many
+# different ways.  This was taken from the old Cygnus configure script
+# with only minor changes.  It should be cleaned up.
+
+# FIXME: The general approach of picking and choosing which
+# directories to configure, other than machine_dir and sys_dir, is
+# potentially confusing.
+
+# It uses the following shell variables:
+#   host		The configuration host
+#   host_cpu		The configuration host CPU
+#   newlib_mb		--enable-newlib-mb ("yes", "no")
+#   target_optspace	--enable-target-optspace ("yes", "no", "")
+#   newlib_multithread	--enable-newlib-multithread ("yes", "no", "yes")
+#   newlib_elix_level	--enable-newlib-elix-level ("1","2","3","4") ("4")
+#   newlib_io_c99_formats --enable-newlib-io-c99-formats ("yes", "no", "")
+#   newlib_io_long_long --enable-newlib-io-long-long ("yes", "no", "")
+#   newlib_io_long_double --enable-newlib-io-long-double ("yes", "no", "")
+
+# It sets the following shell variables:
+#   newlib_cflags	Special CFLAGS to use when building
+#   machine_dir		Subdirectory of libc/machine to configure
+#   sys_dir		Subdirectory of libc/sys to configure
+#   have_sys_mach_dir	Is there a machine subdirectory in sys subdirectory
+#   posix_dir		"posix" to build libc/posix, "" otherwise
+#   signal_dir		"signal" to build libc/signal, "" otherwise
+#   stdio64_dir		"stdio64" to build libc/stdio64, "" otherwise
+#   syscall_dir		"syscalls" to build libc/syscalls, "" otherwise
+#   unix_dir		"unix" to build libc/unix, "" otherwise
+#   use_libtool         flag: use libtool to build newlib?
+#   aext                library extension - needed for libtool support
+#   oext                object file extension - needed for libtool support
+#   lpfx		library object prefix - generated when no libtool
+#   crt1                name of crt1 object if one is provided
+#   crt1_dir            directory where crt1 object is found
+#   have_crt0		"yes"/"no" if crt0 is/isn't provided.
+#			"" if crt0 is provided when sys_dir is set
+#   noinclude		list of include files to not install
+
+newlib_cflags=
+libm_machine_dir=
+machine_dir=
+sys_dir=
+posix_dir=
+signal_dir=signal
+stdio_dir=stdio
+stdio64_dir=
+xdr_dir=
+syscall_dir=
+unix_dir=
+noinclude=
+mach_add_setjmp=
+crt1=
+crt1_dir=
+have_crt0=
+use_libtool=no
+have_sys_mach_dir=no
+default_newlib_io_c99_formats=no
+default_newlib_io_long_long=no
+default_newlib_io_long_double=no
+default_newlib_io_pos_args=no
+default_newlib_atexit_dynamic_alloc=yes
+default_newlib_nano_malloc=no
+aext=a
+oext=o
+lpfx="lib_a-"
+
+case "${target_optspace}:${host}" in
+  yes:*)
+    newlib_cflags="${newlib_cflags} -Os"
+    ;;
+  :m32r-* | :d10v-* | :d30v-* | :avr-* | :m32c-* | :msp430*-* | :nds32* | :rl78-* )
+    newlib_cflags="${newlib_cflags} -Os"
+    ;;
+  no:* | :*)
+    ;;
+esac
+
+# Get the source directories to use for the CPU type.
+# machine_dir should supply CPU dependent routines, such as setjmp.
+# newlib_cflags is passed to gcc when compiling.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host_cpu}" in
+  a29k)
+	machine_dir=a29k
+	;;
+  aarch64*)
+	machine_dir=aarch64
+	libm_machine_dir=aarch64
+	;;
+  arc*)
+	machine_dir=arc
+	;;
+  arm*)
+	machine_dir=arm
+	libm_machine_dir=arm
+	;;
+  avr*)
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -mcall-prologues"
+	;;
+  bfin)
+	machine_dir=bfin
+	;;
+  cr16*)
+	machine_dir=cr16
+       ;;
+  cris | crisv32)
+	machine_dir=cris
+	;;
+  crx*)
+	machine_dir=crx
+	;;
+  d10v*)
+	machine_dir=d10v
+	;;
+  d30v*)
+	machine_dir=d30v
+	;;
+  epiphany)
+	machine_dir=epiphany
+	;;
+  fido)
+	machine_dir=m68k
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  fr30)
+	machine_dir=fr30
+	;;
+  frv)
+	machine_dir=frv
+        ;;
+  ft32*)
+        machine_dir=ft32
+        newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED"
+        ;;
+  h8300)
+	machine_dir=h8300
+	;;
+  h8500)
+	machine_dir=h8500
+	;;
+  hppa*)
+	machine_dir=hppa
+	;;
+  i960)
+	machine_dir=i960
+	;;
+  i[34567]86)
+	# Don't use for these since they provide their own setjmp.
+	case ${host} in
+	*-*-sco* | *-*-cygwin*) 
+		libm_machine_dir=i386
+		machine_dir=i386
+		;;
+	*) 
+		libm_machine_dir=i386
+		machine_dir=i386
+		mach_add_setjmp=true
+		;;
+	esac
+	;;
+  ia64*)
+	;;
+  iq2000)
+	machine_dir=iq2000
+	;;
+  lm32)
+	machine_dir=lm32
+	;;
+  m32c)
+	machine_dir=m32c	
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	;;
+
+  m32r*)
+	machine_dir=m32r
+	;;
+
+  m68hc11|m6811|m68hc12|m6812)
+	machine_dir=m68hc11
+	newlib_cflags="-DPREFER_SIZE_OVER_SPEED -Os -mrelax"
+	CFLAGS="-g -Os"
+	;;
+  
+  m68*)
+	machine_dir=m68k
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  m88k)
+	machine_dir=m88k
+	newlib_cflags="${newlib_cflags} -m88000"
+	;;
+  m88110)
+	machine_dir=m88k
+	newlib_cflags="${newlib_cflags} -m88110"
+	;;
+  mcore)
+	;;
+  microblaze*)
+	machine_dir=microblaze
+	;;
+  mep)
+	machine_dir=mep
+	;;
+  mips*)
+	machine_dir=mips
+	;;
+  mmix)
+	;;
+  mn10200)
+	machine_dir=mn10200
+	;;
+  mn10300)
+	default_newlib_io_long_long="yes"
+	machine_dir=mn10300
+	;;
+  moxie)
+	machine_dir=moxie
+        ;;
+  msp430*)
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	newlib_cflags="${newlib_cflags} -mOs "
+	newlib_cflags="${newlib_cflags} -mhwmult=none "
+	machine_dir=msp430
+	default_newlib_nano_malloc="yes"
+	;;
+  mt*)
+	machine_dir=mt
+	;;
+  nds32*)
+	machine_dir=nds32
+	libm_machine_dir=nds32
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections"
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME"
+	;;
+  nios2*)
+	machine_dir=nios2
+	;;
+  or1k*|or1knd*)
+	machine_dir=or1k
+	;;
+  powerpc*)
+	machine_dir=powerpc
+	;;
+  rl78)
+	machine_dir=rl78
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  rx)
+	machine_dir=rx
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  sh | sh64)
+	machine_dir=sh
+	;;
+  sparc*)
+	machine_dir=sparc
+	# FIXME: Might wish to make MALLOC_ALIGNMENT more generic.
+	newlib_cflags="${newlib_cflags} -DMALLOC_ALIGNMENT=8"
+	;;
+  tic4x|c4x)
+	machine_dir=tic4x
+	;;
+  tic6x)
+	machine_dir=tic6x
+	;;
+  tic80*)
+	machine_dir=tic80
+	;;
+  v70)
+	;;
+  v810)
+	;;
+  v850*)
+	machine_dir=v850
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED "
+	;;
+  visium)
+	machine_dir=visium
+	;;
+  w65*)
+	machine_dir=w65
+	;;
+  x86_64)
+	machine_dir=x86_64
+	;;
+  xc16x*)
+        machine_dir=xc16x
+        ;;
+  xstormy16)
+	machine_dir=xstormy16
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED"
+	newlib_cflags="${newlib_cflags} -DPREFER_SIZE_OVER_SPEED"
+        ;;
+  z8k)
+	machine_dir=z8k
+	;;
+  spu)
+	stdio_dir=
+	libm_machine_dir=spu
+	machine_dir=spu
+	newlib_cflags="${newlib_cflags} -D_POSIX_MODE"
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	newlib_cflags="${newlib_cflags} -ffunction-sections -fdata-sections "
+	;;
+  *)
+	echo '***' "Newlib does not support CPU ${host_cpu}" 1>&2
+	exit 1
+	;;
+esac
+
+# Disable thread support if requested.
+
+if [ "${newlib_multithread}" = "no" ] ; then
+	newlib_cflags="${newlib_cflags} -D__SINGLE_THREAD__"
+fi
+
+# Disable syscall support if requested.
+
+if [ "${newlib_may_supply_syscalls}" = "no" ] ; then
+        newlib_cflags="${newlib_cflags} -D__NO_SYSCALLS__"
+fi
+
+# Enable multibyte support if requested or it is defaulted
+# for target.
+
+if [ "x${newlib_mb}" = "x" ]; then
+	case "${host}" in
+  	  i[34567]86-pc-linux-*|*-*-cygwin*)
+		newlib_mb=yes
+	  	;;
+	esac
+fi
+
+# Disable printf/scanf floating-point support if requested.
+
+if [ "${newlib_io_float}" = "no" ] ; then
+	newlib_cflags="${newlib_cflags} -DNO_FLOATING_POINT"
+fi
+
+# Verify if shared newlib support is allowed and set appropriate variables
+# We don't want to use libtool for platforms that we are not going to
+# support shared libraries.  This is because it adds executable tests which
+# we don't want for most embedded platforms.
+case "${host}" in
+  i[34567]86-pc-linux-*)
+    use_libtool=yes
+    have_sys_mach_dir=yes
+    stdio64_dir=stdio64
+    oext=lo
+    lpfx=
+    aext=la ;;
+  *) ;; #shared library not supported for ${host}
+esac
+
+# Get the source directories to use for the host.  unix_dir is set
+# to unix to get some standard Unix routines.  posix_dir is set to get some
+# standard Posix routines.  sys_dir should supply system dependent routines
+# including crt0.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host}" in
+  *-*-cygwin*)
+	posix_dir=posix
+	stdio64_dir=stdio64
+	xdr_dir=xdr
+	;;
+  *-*-netware*)
+	signal_dir=
+	sys_dir=netware
+	;;
+  *-*-rtems*)			# generic RTEMS support
+	sys_dir=rtems
+	posix_dir=posix
+	unix_dir=unix
+	;;
+  *-*-tirtos*)
+	sys_dir=tirtos
+	have_crt0="no"
+	;;
+  a29k-*-*)
+	sys_dir=a29khif
+	signal_dir=
+	;;
+  arm*-*-*)
+	sys_dir=arm
+	if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
+	  have_crt0="no"
+	fi
+	;;
+  bfin-*-*)
+	sys_dir=
+	;;
+  cr16-*-*)
+	sys_dir=
+	;;
+  crx*)
+	sys_dir=
+	;;
+  d10v*)
+	sys_dir=d10v
+	;;
+  d30v*)
+	sys_dir=
+	;;
+  epiphany-*-*)
+	sys_dir=epiphany
+	# crt0 is provided by libgloss.
+	have_crt0="no"
+	;;
+  frv*)
+        sys_dir=
+        ;;
+  ft32*)
+        sys_dir=
+        ;;
+  h8300-*-hms*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-elf*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-coff*)
+	sys_dir=h8300hms
+	;;
+  h8300-*-xray*)
+	sys_dir=h8300xray
+	;;
+  h8500-*-hms*)
+	sys_dir=h8500hms
+	;;
+  h8500-*-elf*)
+	sys_dir=h8500hms
+	;;
+  i[34567]86-*-rdos*)
+	sys_dir=rdos
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	newlib_cflags="${newlib_cflags} -D_I386MACH_DISABLE_HW_INTERRUPTS"
+	;;
+  i[34567]86-*-sco*)
+	sys_dir=sysvi386
+	unix_dir=unix
+	;;
+  i[34567]86-pc-linux-*)
+	sys_dir=linux
+	unix_dir=unix
+	posix_dir=posix
+	crt1=crt1.o
+	crt1_dir=libc/sys/${sys_dir}	
+	gcc_dir=`gcc -print-search-dirs | awk '/^install:/{print $2}'`
+	default_newlib_io_c99_formats="yes"
+	default_newlib_io_long_double="yes"
+	default_newlib_io_long_long="yes"
+	default_newlib_io_pos_args="yes"
+	#newlib_cflags="${newlib_cflags} -Werror" # DEBUGGING ONLY;BREAKS BUILD
+	newlib_cflags="${newlib_cflags} -Wall"
+	newlib_cflags="${newlib_cflags} -DHAVE_FCNTL"
+	newlib_cflags="${newlib_cflags} -DHAVE_GETOPT"
+	newlib_cflags="${newlib_cflags} -D_NO_POSIX_SPAWN"
+	# --- Required when building a shared library ------------------------
+	newlib_cflags="${newlib_cflags} -fPIC -D_I386MACH_NEED_SOTYPE_FUNCTION"
+	# --- The three lines below are optional ------------------------------
+	##newlib_cflags="${newlib_cflags} -nostdinc"
+	##newlib_cflags="${newlib_cflags} -I`newlib-flags --kernel-dir`/include"
+	##newlib_cflags="${newlib_cflags} -idirafter ${gcc_dir}include"
+	;;
+
+  m68hc11-*-*|m6811-*-*|m6812-*-*|m68hc12-*-*)
+	;;
+
+  m68k-sun-sunos*)
+	unix_dir=unix
+	;;
+  m8*-bug-*)
+	sys_dir=m88kbug
+	;;
+  mep-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  microblaze*-*-*)
+	machine_dir=microblaze
+	;;
+  mips*-dec-*)
+	sys_dir=decstation
+	;;
+  mmix-knuth-mmixware)
+	sys_dir=mmixware
+	;;
+  moxie*)
+        sys_dir=
+        ;;
+  nios2*)
+	sys_dir=
+	;;
+  or1k-*-elf | or1knd-*-elf)
+	sys_dir=or1k
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED "
+	have_crt0="no"
+	;;
+  powerpcle-*-pe)
+	posix_dir=posix
+	;;
+  sh*-*)
+	sys_dir=sh
+	;;
+  sparc-sun-sunos*)
+	sys_dir=sun4
+	unix_dir=unix
+	;;
+  sparc64*)
+	sys_dir=sparc64
+	unix_dir=unix
+	;;
+  spu-*-*)
+	default_newlib_io_long_long="yes"
+	default_newlib_atexit_dynamic_alloc="no"
+	;;
+  tic6x*)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	have_crt0="no"
+	;;
+  tic80*)
+	sys_dir=tic80
+	;;
+  v70-nec-*)
+	sys_dir=sysvnecv70
+	;;
+  v810-*-*)
+	sys_dir=sysnec810
+	;;
+  v850*-*-*)
+	sys_dir=sysnecv850
+        if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
+          have_crt0="no"
+        fi
+	;;
+  visium-*-*)
+	sys_dir=
+	;;
+  w65-*-*)
+	sys_dir=w65
+	;;
+  z8k-*-coff)
+	sys_dir=z8ksim
+	;;
+esac
+
+# Host specific flag settings -- usually for features that are not
+# general enough or broad enough to be handled above.
+# THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.
+
+case "${host}" in
+  *-*-cygwin*)
+	test -z "$cygwin_srcdir" && cygwin_srcdir=`cd ${srcdir}/../winsup/cygwin; pwd`
+	export cygwin_srcdir
+	default_newlib_io_c99_formats="yes"
+	default_newlib_io_long_long="yes"
+	default_newlib_io_long_double="yes"
+	default_newlib_io_pos_args="yes"
+	CC="${CC} -I${cygwin_srcdir}/include"
+	newlib_cflags="${newlib_cflags} -DHAVE_OPENDIR -DHAVE_RENAME -DSIGNAL_PROVIDED -D_COMPILING_NEWLIB -DHAVE_BLKSIZE -DHAVE_FCNTL -DMALLOC_PROVIDED"
+	syscall_dir=syscalls
+	;;
+# RTEMS supplies its own versions of some routines:
+#       malloc()            (reentrant version)
+#       exit()              RTEMS has a "global" reent to flush
+#       signal()/raise()    RTEMS has its own including pthread signals
+#       _XYZ_r()            RTEMS has its own reentrant routines
+#
+#  NOTE: When newlib malloc uses a semaphore, RTEMS will switch to that.
+  *-*-rtems*)
+	default_newlib_io_long_long="yes"
+	default_newlib_io_c99_formats="yes"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DEXIT_PROVIDED -DSIGNAL_PROVIDED -DREENTRANT_SYSCALLS_PROVIDED -DHAVE_NANOSLEEP -DHAVE_BLKSIZE -DHAVE_FCNTL -DHAVE_ASSERT_FUNC"
+        # turn off unsupported items in posix directory 
+	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_SIGSET -D_NO_WORDEXP -D_NO_POPEN -D_NO_POSIX_SPAWN"
+        # turn off using cli/sti in i386 setjmp/longjmp
+	newlib_cflags="${newlib_cflags} -D_I386MACH_ALLOW_HW_INTERRUPTS"
+	;;
+# VxWorks supplies its own version of malloc, and the newlib one
+# doesn't work because VxWorks does not have sbrk.
+  *-wrs-vxworks*)
+	newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DMISSING_SYSCALL_NAMES -DHAVE_FCNTL"
+	;;
+# TIRTOS supplies its own version of malloc
+  *-*-tirtos*)
+	newlib_cflags="${newlib_cflags} -D__DYNAMIC_REENT__ -DMALLOC_PROVIDED"
+	;;
+# UDI doesn't have exec, so system() should fail the right way
+  a29k-amd-udi)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC"
+	syscall_dir=syscalls
+	;;
+  aarch64*-*-*)
+	default_newlib_io_long_long="yes"
+	syscall_dir=syscalls
+	;;
+  arc*-*-*)
+	syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	;;
+  arm*-*-pe)
+	syscall_dir=syscalls
+	;;
+  arm*-*-*)
+	syscall_dir=syscalls
+# If newlib is supplying syscalls, select which debug protocol is being used.
+# ARM_RDP_MONITOR selects the Demon monitor.
+# ARM_RDI_MONITOR selects the Angel monitor.
+# If neither are defined, then hard coded defaults will be used
+# to create the program's environment.
+# If --disable-newlib-supplied-syscalls is specified, then the end-user
+# may specify the protocol via gcc spec files supplied by libgloss.
+	if [ "x${newlib_may_supply_syscalls}" = "xyes" ] ; then
+#         newlib_cflags="${newlib_cflags} -DARM_RDP_MONITOR"
+	  newlib_cflags="${newlib_cflags} -DARM_RDI_MONITOR"
+	fi
+	;;
+  avr*)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	;;
+  bfin*)
+	syscall_dir=syscalls
+	;;
+  cris-*-* | crisv32-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -D_USE_WRITE -DCOMPACT_CTYPE"
+	syscall_dir=syscalls
+	;;
+  cr16-*-*)
+	syscall_dir=syscalls
+	;;
+  crx-*-*)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  d10v*)
+	newlib_cflags="${newlib_cflags} -DSMALL_MEMORY"
+	syscall_dir=syscalls
+	;;
+  d30v*)
+	newlib_cflags="${newlib_cflags} -DABORT_MESSAGE -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  epiphany*)
+	syscall_dir=syscalls
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED"
+	;;
+  fido-*-elf)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  fr30-*-*)
+	syscall_dir=syscalls
+	;;
+  frv-*-*)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+        ;;
+  ft32*-*-*)
+        syscall_dir=syscalls
+        ;;
+  h8300*-*-*)
+	syscall_dir=syscalls	
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	# Simulator only extensions for H8300.
+	# Uncomment the next line to enable them.
+	# newlib_cflags="${newlib_cflags} -D__SIMULATOR__"
+	;;	
+  h8500-*-*)
+	syscall_dir=syscalls	
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	;;	
+  i[34567]86-*-sco*)
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED -DHAVE_FCNTL"
+	;;
+  i[34567]86-*-netware*)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DNO_EXEC -DABORT_PROVIDED -DCLOCK_PROVIDED -DMALLOC_PROVIDED -DHAVE_FCNTL"
+	;;
+  iq2000*)
+	syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	;;
+  lm32-*-*)
+	syscall_dir=syscalls
+	;;
+  m32c-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DABORT_PROVIDED"
+	syscall_dir=
+  	;;
+  m32r-*-*)
+	# Pass -msdata=sdata so _impure_ptr goes in .sdata.
+	# We don't generate sda relocs however for upward compatibility.
+	# FIXME: This is necessary because the default multilib doesn't
+	# use --print-multi-lib.
+	newlib_cflags="${newlib_cflags} -msdata=sdata"
+	syscall_dir=syscalls
+	;;
+  m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)
+	newlib_cflags="${newlib_cflags} -DNO_EXEC -DABORT_PROVIDED -DSMALL_MEMORY -DMISSING_SYSCALL_NAMES"
+	;;
+  m68k-unknown-elf)
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  mcore-*-*)
+	syscall_dir=syscalls
+	;;
+  microblaze*-*-*)
+   	default_newlib_io_long_long="yes"
+ 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES -DSMALL_MEMORY -D_REENT_SMALL"
+	;;
+  mips64vr*-*-*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  mips*-*-elf*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  mmix-*)
+	syscall_dir=syscalls
+	# We need every symbol 32-bit aligned, so the invalid
+	# construct with attribute ((alias ("_ctype_b+127"))) breaks.
+	newlib_cflags="${newlib_cflags} -DCOMPACT_CTYPE"
+	;;
+  mn10?00-*-*)
+	syscall_dir=syscalls
+	;;
+  moxie-*-elf* | moxie-*-rtems*)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+        ;;
+  moxie-*-moxiebox)
+        syscall_dir=syscalls
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -Os -DPREFER_SIZE_OVER_SPEED -DSMALL_MEMORY"
+        ;;
+  nios2*)
+	syscall_dir=
+	newlib_cflags="${newlib_cflags} -DHAVE_RENAME -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	;;
+  nds32*)
+	syscall_dir=syscalls
+	;;
+  or1k*|or1knd*)
+	syscall_dir=syscalls
+	;;
+  powerpc*-*-eabialtivec*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpc*-*-eabispe*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpc*-*-eabi* | \
+  powerpc*-*-elf* | \
+  powerpc*-*-linux* | \
+  powerpc*-*-rtem* | \
+  powerpc*-*-sysv* | \
+  powerpc*-*-solaris*)
+	default_newlib_io_long_long="yes"
+	newlib_cflags="${newlib_cflags} -mrelocatable-lib -mno-eabi -mstrict-align -DMISSING_SYSCALL_NAMES"
+	;;
+  powerpcle-*-pe)
+	newlib_cflags="${newlib_cflags} -DHAVE_OPENDIR -DHAVE_RENAME -DHAVE_FCNTL -D_NO_POSIX_SPAWN"
+	syscall_dir=syscalls
+	;;
+  sh*-*-*)
+	default_newlib_io_long_long="yes"
+	syscall_dir=syscalls
+	;;
+  sparc-sun-sunos*)
+	newlib_cflags="${newlib_cflags} -DSIGNAL_PROVIDED"
+	;;
+  sparc64-*-*)
+	newlib_cflags="${newlib_cflags} -DREENTRANT_SYSCALLS_PROVIDED -DHAVE_BLKSIZE -DHAVE_FCNTL"
+	# This either belongs elsewhere or nowhere. But I need *something*,
+	# so for now it's here ...
+	case "${host_os}" in
+	  aoutv8 | *32p)
+		newlib_cflags="${newlib_cflags} -DTARGET_PTR_SIZE=32" ;;
+	  *)
+		newlib_cflags="${newlib_cflags} -DTARGET_PTR_SIZE=64" ;;
+	esac
+	;;
+  tic6x*)
+	syscall_dir=
+	newlib_cflags="${newlib_cflags} -DCLOCK_PROVIDED"
+	;;
+  tic80*)
+	syscall_dir=syscalls
+	;;
+  v850*-*-*)
+	syscall_dir=syscalls
+	;;
+  visium-*-*)
+	newlib_cflags="${newlib_cflags} -DCLOCK_PROVIDED -DHAVE_SYSTEM -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+  w65-*-*)
+	syscall_dir=syscalls	
+	newlib_cflags="${newlib_cflags} -DSMALL_DTOA -DSMALL_MEMORY"
+	;;
+  xc16x-*)
+          syscall_dir=syscalls
+        ;;
+  xstormy16-*-*)
+	syscall_dir=syscalls
+	;;
+  z8k-*-*)
+	syscall_dir=syscalls
+	;;
+  *)
+	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
+	syscall_dir=
+	;;
+esac
+
+# Use defaults for certain settings if not specified by user
+
+# Enable C99 format support in I/O routines if requested.
+if [ "x${newlib_io_c99_formats}" = "x" ]; then
+	if [ ${default_newlib_io_c99_formats} = "yes" ]; then
+		newlib_io_c99_formats="yes";
+	fi
+fi
+
+# Enable long long support in I/O routines if requested.
+if [ "x${newlib_io_long_long}" = "x" ]; then
+	if [ ${default_newlib_io_long_long} = "yes" ]; then
+		newlib_io_long_long="yes";
+	fi
+fi
+
+# Enable long double support in I/O routines if requested.
+if [ "x${newlib_io_long_double}" = "x" ]; then
+	if [ ${default_newlib_io_long_double} = "yes" ]; then
+		newlib_io_long_double="yes";
+	fi
+fi
+
+# Enable printf positional argument support if requested.
+if [ "x${newlib_io_pos_args}" = "x" ]; then
+	if [ ${default_newlib_io_pos_args} = "yes" ]; then
+		newlib_io_pos_args="yes";
+	fi
+fi
+
+# Disable atexit dynamic allocation if requested.
+if [ "x${newlib_atexit_dynamic_alloc}" = "x" ]; then
+	if [ ${default_newlib_atexit_dynamic_alloc} = "yes" ]; then
+		newlib_atexit_dynamic_alloc="yes"; 
+	fi
+fi
+
+# Enable nano-malloc if requested.
+if [ "x${newlib_nano_malloc}" = "x" ]; then
+	if [ ${default_newlib_nano_malloc} = "yes" ]; then
+		newlib_nano_malloc="yes";
+	fi
+fi
+
+# Remove rpc headers if xdr_dir not specified
+if [ "x${xdr_dir}" = "x" ]; then
+	noinclude="${noinclude} rpc/types.h rpc/xdr.h"
+fi
+
+if test -z "${have_crt0}" && test -n "${sys_dir}"; then
+  have_crt0="yes"
+fi
diff -rupN old/newlib/libc/include/sys/_intsup.h new/newlib/libc/include/sys/_intsup.h
--- old/newlib/libc/include/sys/_intsup.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/_intsup.h	2016-04-29 09:21:24.087384166 -0500
@@ -79,14 +79,15 @@
 #elif (__INTPTR_TYPE__ == 1 || __INTPTR_TYPE__ == 3)
 #define _INTPTR_EQ_SHORT
 #else
-#error "Unable to determine type definition of intptr_t"
+// #error "Unable to determine type definition of intptr_t"
+#define _INTPTR_EQ_INT
 #endif
 #if (__INT32_TYPE__ == 4 || __INT32_TYPE__ == 6)
 #define _INT32_EQ_LONG
 #elif __INT32_TYPE__ == 2
 /* Nothing to define because int32_t is safe to print as an int. */
 #else
-#error "Unable to determine type definition of int32_t"
+// #error "Unable to determine type definition of int32_t"
 #endif
 
 #if (__INT8_TYPE__ == 0)
diff -rupN old/newlib/libc/include/sys/stat.h new/newlib/libc/include/sys/stat.h
--- old/newlib/libc/include/sys/stat.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/stat.h	2016-04-29 09:21:24.087384166 -0500
@@ -152,8 +152,8 @@ int	_EXFUN(mkfifo,( const char *__path,
 int	_EXFUN(stat,( const char *__restrict __path, struct stat *__restrict __sbuf ));
 mode_t	_EXFUN(umask,( mode_t __mask ));
 
-#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(lstat,( const char *__restrict __path, struct stat *__restrict __buf ));
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(mknod,( const char *__path, mode_t __mode, dev_t __dev ));
 #endif
 
diff -rupN old/newlib/libc/include/sys/utime.h new/newlib/libc/include/sys/utime.h
--- old/newlib/libc/include/sys/utime.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/utime.h	2016-04-29 09:21:24.091384202 -0500
@@ -15,6 +15,8 @@ struct utimbuf
   time_t modtime; 
 };
 
+int utime(const char *filename, const struct utimbuf *times);
+
 #ifdef __cplusplus
 };
 #endif
diff -rupN old/newlib/libc/include/sys/utime.h.orig new/newlib/libc/include/sys/utime.h.orig
--- old/newlib/libc/include/sys/utime.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ new/newlib/libc/include/sys/utime.h.orig	2016-04-29 09:21:24.091384202 -0500
@@ -0,0 +1,22 @@
+#ifndef _SYS_UTIME_H
+#define _SYS_UTIME_H
+
+/* This is a dummy <sys/utime.h> file, not customized for any
+   particular system.  If there is a utime.h in libc/sys/SYSDIR/sys,
+   it will override this one.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct utimbuf 
+{
+  time_t actime;
+  time_t modtime; 
+};
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _SYS_UTIME_H */
diff -rupN old/newlib/libc/posix/closedir.c new/newlib/libc/posix/closedir.c
--- old/newlib/libc/posix/closedir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/closedir.c	2016-04-29 09:21:24.091384202 -0500
@@ -1,71 +1,71 @@
-#ifndef HAVE_OPENDIR
-
-/*
- * Copyright (c) 1983 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)closedir.c	5.9 (Berkeley) 2/23/91";
-#endif /* LIBC_SCCS and not lint */
-
-#include <sys/types.h>
-#include <dirent.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/lock.h>
-
-extern void _cleanupdir (DIR *dirp);
-
-/*
- * close a directory.
- */
-int
-_DEFUN(closedir, (dirp),
-       register DIR *dirp)
-{
-	int rc;
-
-#ifdef HAVE_DD_LOCK
-	__lock_acquire_recursive(dirp->dd_lock);
-#endif
-	rc = close(dirp->dd_fd);
-	_cleanupdir(dirp);
-	free((void *)dirp->dd_buf);
-#ifdef HAVE_DD_LOCK
-	__lock_release_recursive(dirp->dd_lock);
-	__lock_close_recursive(dirp->dd_lock);
-#endif
-	free((void *)dirp);
-	return rc;
-}
-
-#endif /* ! HAVE_OPENDIR */
+// #ifndef HAVE_OPENDIR
+//
+// /*
+//  * Copyright (c) 1983 Regents of the University of California.
+//  * All rights reserved.
+//  *
+//  * Redistribution and use in source and binary forms, with or without
+//  * modification, are permitted provided that the following conditions
+//  * are met:
+//  * 1. Redistributions of source code must retain the above copyright
+//  *    notice, this list of conditions and the following disclaimer.
+//  * 2. Redistributions in binary form must reproduce the above copyright
+//  *    notice, this list of conditions and the following disclaimer in the
+//  *    documentation and/or other materials provided with the distribution.
+//  * 3. All advertising materials mentioning features or use of this software
+//  *    must display the following acknowledgement:
+//  *	This product includes software developed by the University of
+//  *	California, Berkeley and its contributors.
+//  * 4. Neither the name of the University nor the names of its contributors
+//  *    may be used to endorse or promote products derived from this software
+//  *    without specific prior written permission.
+//  *
+//  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+//  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+//  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+//  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+//  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+//  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+//  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+//  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+//  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+//  * SUCH DAMAGE.
+//  */
+//
+// #if defined(LIBC_SCCS) && !defined(lint)
+// static char sccsid[] = "@(#)closedir.c	5.9 (Berkeley) 2/23/91";
+// #endif /* LIBC_SCCS and not lint */
+//
+// #include <sys/types.h>
+// #include <dirent.h>
+// #include <stdlib.h>
+// #include <unistd.h>
+// #include <sys/lock.h>
+//
+// extern void _cleanupdir (DIR *dirp);
+//
+// /*
+//  * close a directory.
+//  */
+// int
+// _DEFUN(closedir, (dirp),
+//        register DIR *dirp)
+// {
+// 	int rc;
+//
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire_recursive(dirp->dd_lock);
+// #endif
+// 	rc = close(dirp->dd_fd);
+// 	_cleanupdir(dirp);
+// 	free((void *)dirp->dd_buf);
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release_recursive(dirp->dd_lock);
+// 	__lock_close_recursive(dirp->dd_lock);
+// #endif
+// 	free((void *)dirp);
+	// return rc;
+// }
+//
+// #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/creat.c new/newlib/libc/posix/creat.c
--- old/newlib/libc/posix/creat.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/creat.c	2016-04-29 09:24:32.177130993 -0500
@@ -1,13 +1,13 @@
-/* creat() "system call" */
-
-/* This is needed by f2c and therefore the SPEC benchmarks.  */
-
-#include <fcntl.h>
-
-int
-_DEFUN(creat, (path, mode), 
-       const char *path _AND 
-       mode_t mode)
-{
-  return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
-}
+// /* creat() "system call" */
+//
+// /* This is needed by f2c and therefore the SPEC benchmarks.  */
+//
+// #include <fcntl.h>
+//
+// int
+// _DEFUN(creat, (path, mode), 
+//        const char *path _AND 
+//        mode_t mode)
+// {
+//   return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
+// }
diff -rupN old/newlib/libc/posix/execl.c new/newlib/libc/posix/execl.c
--- old/newlib/libc/posix/execl.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execl.c	2016-04-29 09:21:24.091384202 -0500
@@ -1,52 +1,52 @@
-#ifndef _NO_EXECVE
-
-/* execl.c */
-
-/* This and the other exec*.c files in this directory require 
-   the target to provide the _execve syscall.  */
-
-#include <_ansi.h>
-#include <unistd.h>
-
-/* Only deal with a pointer to environ, to work around subtle bugs with shared
-   libraries and/or small data systems where the user declares his own
-   'environ'.  */
-static char ***p_environ = &environ;
-
-#ifdef _HAVE_STDC
-
-#include <stdarg.h>
-
-int
-_DEFUN(execl, (path, arg0, ...), 
-      _CONST char *path _AND
-      _CONST char *arg0 _DOTS)
-
-#else
-
-#include <varargs.h>
-
-int
-_DEFUN(execl, (path, arg0, va_alist),
-     _CONST char *path _AND
-     _CONST char *arg0 _AND
-     va_dcl)
-
-#endif
-
-{
-  int i;
-  va_list args;
-  _CONST char *argv[256];
-
-  va_start (args, arg0);
-  argv[0] = arg0;
-  i = 1;
-  do
-      argv[i] = va_arg (args, _CONST char *);
-  while (argv[i++] != NULL);
-  va_end (args);
-
-  return _execve (path, (char * _CONST  *) argv, *p_environ);
-}
-#endif /* !_NO_EXECVE  */
+// #ifndef _NO_EXECVE
+//
+// /* execl.c */
+//
+// /* This and the other exec*.c files in this directory require
+//    the target to provide the _execve syscall.  */
+//
+// #include <_ansi.h>
+// #include <unistd.h>
+//
+// /* Only deal with a pointer to environ, to work around subtle bugs with shared
+//    libraries and/or small data systems where the user declares his own
+//    'environ'.  */
+// static char ***p_environ = &environ;
+//
+// #ifdef _HAVE_STDC
+//
+// #include <stdarg.h>
+//
+// int
+// _DEFUN(execl, (path, arg0, ...),
+//       _CONST char *path _AND
+//       _CONST char *arg0 _DOTS)
+//
+// #else
+//
+// #include <varargs.h>
+//
+// int
+// _DEFUN(execl, (path, arg0, va_alist),
+//      _CONST char *path _AND
+//      _CONST char *arg0 _AND
+//      va_dcl)
+//
+// #endif
+//
+// {
+//   int i;
+//   va_list args;
+//   _CONST char *argv[256];
+//
+//   va_start (args, arg0);
+//   argv[0] = arg0;
+//   i = 1;
+//   do
+//       argv[i] = va_arg (args, _CONST char *);
+//   while (argv[i++] != NULL);
+//   va_end (args);
+//
+//   return _execve (path, (char * _CONST  *) argv, *p_environ);
+// }
+// #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/execle.c new/newlib/libc/posix/execle.c
--- old/newlib/libc/posix/execle.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execle.c	2016-04-29 09:21:24.091384202 -0500
@@ -2,7 +2,7 @@
 
 /* execle.c */
 
-/* This and the other exec*.c files in this directory require 
+/* This and the other exec*.c files in this directory require
    the target to provide the _execve syscall.  */
 
 #include <_ansi.h>
@@ -30,21 +30,21 @@ _DEFUN(execle, (path, arg0, va_alist),
 #endif
 
 {
-  int i;
-  va_list args;
-  _CONST char * _CONST *envp;
-  _CONST char *argv[256];
-
-  va_start (args, arg0);
-  argv[0] = arg0;
-  i = 1;
-  do
-    argv[i] = va_arg (args, _CONST char *);
-  while (argv[i++] != NULL);
-  envp = va_arg (args, _CONST char * _CONST *);
-  va_end (args);
-
-  return _execve (path, (char * _CONST *) argv, (char * _CONST *) envp);
+  // int i;
+  // va_list args;
+  // _CONST char * _CONST *envp;
+  // _CONST char *argv[256];
+  //
+  // va_start (args, arg0);
+  // argv[0] = arg0;
+  // i = 1;
+  // do
+  //   argv[i] = va_arg (args, _CONST char *);
+  // while (argv[i++] != NULL);
+  // envp = va_arg (args, _CONST char * _CONST *);
+  // va_end (args);
+  //
+  // return _execve (path, (char * _CONST *) argv, (char * _CONST *) envp);
 }
 
 #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/execlp.c new/newlib/libc/posix/execlp.c
--- old/newlib/libc/posix/execlp.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execlp.c	2016-04-29 09:21:24.091384202 -0500
@@ -1,48 +1,48 @@
-#ifndef _NO_EXECVE
-
-/* execlp.c */
-
-/* This and the other exec*.c files in this directory require 
-   the target to provide the _execve syscall.  */
-
-#include <_ansi.h>
-#include <unistd.h>
-
-#ifdef _HAVE_STDC
-
-#include <stdarg.h>
-
-int
-_DEFUN(execlp, (path, arg0, ...),
-      _CONST char *path _AND
-      _CONST char *arg0 _DOTS)
-
-#else
-
-#include <varargs.h>
-
-int
-_DEFUN(execlp, (path, arg0, va_alist),
-     _CONST char *path _AND
-     _CONST char *arg0 _AND
-     va_dcl)
-
-#endif
-
-{
-  int i;
-  va_list args;
-  _CONST char *argv[256];
-
-  va_start (args, arg0);
-  argv[0] = arg0;
-  i = 1;
-  do
-      argv[i] = va_arg (args, _CONST char *);
-  while (argv[i++] != NULL);
-  va_end (args);
-
-  return execvp (path, (char * _CONST *) argv);
-}
-
-#endif /* !_NO_EXECVE  */
+// #ifndef _NO_EXECVE
+//
+// /* execlp.c */
+//
+// /* This and the other exec*.c files in this directory require
+//    the target to provide the _execve syscall.  */
+//
+// #include <_ansi.h>
+// #include <unistd.h>
+//
+// #ifdef _HAVE_STDC
+//
+// #include <stdarg.h>
+//
+// int
+// _DEFUN(execlp, (path, arg0, ...),
+//       _CONST char *path _AND
+//       _CONST char *arg0 _DOTS)
+//
+// #else
+//
+// #include <varargs.h>
+//
+// int
+// _DEFUN(execlp, (path, arg0, va_alist),
+//      _CONST char *path _AND
+//      _CONST char *arg0 _AND
+//      va_dcl)
+//
+// #endif
+//
+// {
+//   int i;
+//   va_list args;
+//   _CONST char *argv[256];
+//
+//   va_start (args, arg0);
+//   argv[0] = arg0;
+//   i = 1;
+//   do
+//       argv[i] = va_arg (args, _CONST char *);
+//   while (argv[i++] != NULL);
+//   va_end (args);
+//
+//   return execvp (path, (char * _CONST *) argv);
+// }
+//
+// #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/execv.c new/newlib/libc/posix/execv.c
--- old/newlib/libc/posix/execv.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execv.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,24 +1,24 @@
-#ifndef _NO_EXECVE
-
-/* execv.c */
-
-/* This and the other exec*.c files in this directory require 
-   the target to provide the _execve syscall.  */
-
-#include <_ansi.h>
-#include <unistd.h>
-
-/* Only deal with a pointer to environ, to work around subtle bugs with shared
-   libraries and/or small data systems where the user declares his own
-   'environ'.  */
-static char ***p_environ = &environ;
-
-int
-_DEFUN (execv, (path, argv), 
-	const char *path _AND
-	char * const argv[])
-{
-  return _execve (path, (char * _CONST *) argv, *p_environ);
-}
-
-#endif /* !_NO_EXECVE  */
+// #ifndef _NO_EXECVE
+//
+// /* execv.c */
+//
+// /* This and the other exec*.c files in this directory require
+//    the target to provide the _execve syscall.  */
+//
+// #include <_ansi.h>
+// #include <unistd.h>
+//
+// /* Only deal with a pointer to environ, to work around subtle bugs with shared
+//    libraries and/or small data systems where the user declares his own
+//    'environ'.  */
+// static char ***p_environ = &environ;
+//
+// int
+// _DEFUN (execv, (path, argv),
+// 	const char *path _AND
+// 	char * const argv[])
+// {
+//   return _execve (path, (char * _CONST *) argv, *p_environ);
+// }
+//
+// #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/execve.c new/newlib/libc/posix/execve.c
--- old/newlib/libc/posix/execve.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execve.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,21 +1,21 @@
-#ifndef _NO_EXECVE
-
-/* execve.c */
-
-/* This and the other exec*.c files in this directory require 
-   the target to provide the _execve syscall.  */
-
-
-#include <unistd.h>
-
-
-int
-_DEFUN(execve, (path, argv, envp),
-      const char *path _AND
-      char * const argv[] _AND
-      char * const envp[])
-{
-  return _execve (path, argv, envp);
-}
-
-#endif /* !_NO_EXECVE  */
+// #ifndef _NO_EXECVE
+//
+// /* execve.c */
+//
+// /* This and the other exec*.c files in this directory require
+//    the target to provide the _execve syscall.  */
+//
+//
+// #include <unistd.h>
+//
+//
+// int
+// _DEFUN(execve, (path, argv, envp),
+//       const char *path _AND
+//       char * const argv[] _AND
+//       char * const envp[])
+// {
+//   return _execve (path, argv, envp);
+// }
+//
+// #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/execvp.c new/newlib/libc/posix/execvp.c
--- old/newlib/libc/posix/execvp.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/execvp.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,73 +1,73 @@
-#ifndef _NO_EXECVE
-
-/* execvp.c */
-
-/* This and the other exec*.c files in this directory require 
-   the target to provide the _execve syscall.  */
-
-#include <_ansi.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <dirent.h>
-#include <string.h>
-#include <errno.h>
-#include <ctype.h>
-
-#define PATH_DELIM ':'
-
-/*
- * Copy string, until c or <nul> is encountered.
- * NUL-terminate the destination string (s1).
- */
-
-static char *
-_DEFUN (strccpy, (s1, s2, c),
-	char *s1 _AND
-	char *s2 _AND
-	char c)
-{
-  char *dest = s1;
-
-  while (*s2 && *s2 != c)
-    *s1++ = *s2++;
-  *s1 = 0;
-
-  return dest;
-}
-
-int
-_DEFUN (execvp, (file, argv),
-	_CONST char *file _AND
-	char * _CONST argv[])
-{
-  char *path = getenv ("PATH");
-  char buf[MAXNAMLEN];
-
-  /* If $PATH doesn't exist, just pass FILE on unchanged.  */
-  if (!path)
-    return execv (file, argv);
-
-  /* If FILE contains a directory, don't search $PATH.  */
-  if (strchr (file, '/')
-      )
-    return execv (file, argv);
-
-  while (*path)
-    {
-      strccpy (buf, path, PATH_DELIM);
-      /* An empty entry means the current directory.  */
-      if (*buf != 0 && buf[strlen(buf) - 1] != '/')
-	strcat (buf, "/");
-      strcat (buf, file);
-      if (execv (buf, argv) == -1 && errno != ENOENT)
-	return -1;
-      while (*path && *path != PATH_DELIM)
-	path++;
-      if (*path == PATH_DELIM)
-	path++;			/* skip over delim */
-    }
-
-  return -1;
-}
-
-#endif /* !_NO_EXECVE  */
+// #ifndef _NO_EXECVE
+//
+// /* execvp.c */
+//
+// /* This and the other exec*.c files in this directory require
+//    the target to provide the _execve syscall.  */
+//
+// #include <_ansi.h>
+// #include <stdlib.h>
+// #include <unistd.h>
+// #include <dirent.h>
+// #include <string.h>
+// #include <errno.h>
+// #include <ctype.h>
+//
+// #define PATH_DELIM ':'
+//
+// /*
+//  * Copy string, until c or <nul> is encountered.
+//  * NUL-terminate the destination string (s1).
+//  */
+//
+// static char *
+// _DEFUN (strccpy, (s1, s2, c),
+// 	char *s1 _AND
+// 	char *s2 _AND
+// 	char c)
+// {
+//   char *dest = s1;
+//
+//   while (*s2 && *s2 != c)
+//     *s1++ = *s2++;
+//   *s1 = 0;
+//
+//   return dest;
+// }
+//
+// int
+// _DEFUN (execvp, (file, argv),
+// 	_CONST char *file _AND
+// 	char * _CONST argv[])
+// {
+//   char *path = getenv ("PATH");
+//   char buf[MAXNAMLEN];
+//
+//   /* If $PATH doesn't exist, just pass FILE on unchanged.  */
+//   if (!path)
+//     return execv (file, argv);
+//
+//   /* If FILE contains a directory, don't search $PATH.  */
+//   if (strchr (file, '/')
+//       )
+//     return execv (file, argv);
+//
+//   while (*path)
+//     {
+//       strccpy (buf, path, PATH_DELIM);
+//       /* An empty entry means the current directory.  */
+//       if (*buf != 0 && buf[strlen(buf) - 1] != '/')
+// 	strcat (buf, "/");
+//       strcat (buf, file);
+//       if (execv (buf, argv) == -1 && errno != ENOENT)
+// 	return -1;
+//       while (*path && *path != PATH_DELIM)
+// 	path++;
+//       if (*path == PATH_DELIM)
+// 	path++;			/* skip over delim */
+//     }
+//
+//   return -1;
+// }
+//
+// #endif /* !_NO_EXECVE  */
diff -rupN old/newlib/libc/posix/_isatty.c new/newlib/libc/posix/_isatty.c
--- old/newlib/libc/posix/_isatty.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/_isatty.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,21 +1,21 @@
-/* isatty.c */
+// /* isatty.c */
+//
+// /* Dumb implementation so programs will at least run.  */
+//
+// #include <sys/stat.h>
+// #include <errno.h>
 
-/* Dumb implementation so programs will at least run.  */
-
-#include <sys/stat.h>
-#include <errno.h>
-
-int
-_DEFUN(_isatty, (fd), int fd)
-{
-  struct stat buf;
-
-  if (fstat (fd, &buf) < 0) {
-    errno = EBADF;
-    return 0;
-  }
-  if (S_ISCHR (buf.st_mode))
-    return 1;
-  errno = ENOTTY;
-  return 0;
-}
+// int
+// _DEFUN(_isatty, (fd), int fd)
+// {
+//   struct stat buf;
+//
+//   if (fstat (fd, &buf) < 0) {
+//     errno = EBADF;
+//     return 0;
+//   }
+//   if (S_ISCHR (buf.st_mode))
+//     return 1;
+//   errno = ENOTTY;
+//   return 0;
+// }
diff -rupN old/newlib/libc/posix/isatty.c new/newlib/libc/posix/isatty.c
--- old/newlib/libc/posix/isatty.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/isatty.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,10 +1,10 @@
-/* isatty.c */
-
-#include <unistd.h>
-#include <reent.h>
-
-int
-_DEFUN(isatty, (fd), int fd)
-{
-  return _isatty (fd);
-}
+// /* isatty.c */
+//
+// #include <unistd.h>
+// #include <reent.h>
+//
+// int
+// _DEFUN(isatty, (fd), int fd)
+// {
+//   return _isatty (fd);
+// }
diff -rupN old/newlib/libc/posix/Makefile.am new/newlib/libc/posix/Makefile.am
--- old/newlib/libc/posix/Makefile.am	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/Makefile.am	2016-04-29 09:21:24.095384236 -0500
@@ -1,6 +1,6 @@
 ## Process this file with automake to generate Makefile.in
 
-AUTOMAKE_OPTIONS = cygnus
+AUTOMAKE_OPTIONS = 
 
 INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 
diff -rupN old/newlib/libc/posix/Makefile.in new/newlib/libc/posix/Makefile.in
--- old/newlib/libc/posix/Makefile.in	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/Makefile.in	2016-04-29 09:21:24.095384236 -0500
@@ -287,7 +287,7 @@ target_alias = @target_alias@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
-AUTOMAKE_OPTIONS = cygnus
+AUTOMAKE_OPTIONS = 
 INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
 GENERAL_SOURCES = \
 	closedir.c collate.c collcmp.c creat.c \
@@ -345,9 +345,9 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --cygnus posix/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE)  posix/Makefile'; \
 	$(am__cd) $(top_srcdir) && \
-	  $(AUTOMAKE) --cygnus posix/Makefile
+	  $(AUTOMAKE)  posix/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
diff -rupN old/newlib/libc/posix/opendir.c new/newlib/libc/posix/opendir.c
--- old/newlib/libc/posix/opendir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/opendir.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,96 +1,96 @@
-#ifndef HAVE_OPENDIR
-
-/*
- * Copyright (c) 1983 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)opendir.c	5.11 (Berkeley) 2/23/91";
-#endif /* LIBC_SCCS and not lint */
-
-#include <dirent.h>
-#include <fcntl.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <sys/lock.h>
-
-/*
- * open a directory.
- */
-DIR *
-_DEFUN(opendir, (name),
-	const char *name)
-{
-	register DIR *dirp;
-	register int fd;
-	int rc = 0;
-
-	if ((fd = open(name, 0)) == -1)
-		return NULL;
-#ifdef HAVE_FCNTL
-	rc = fcntl(fd, F_SETFD, 1);
-#endif
-	if (rc == -1 ||
-	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
-		close (fd);
-		return NULL;
-	}
-	/*
-	 * If CLSIZE is an exact multiple of DIRBLKSIZ, use a CLSIZE
-	 * buffer that it cluster boundary aligned.
-	 * Hopefully this can be a big win someday by allowing page trades
-	 * to user space to be done by getdirentries()
-	 */
-	dirp->dd_buf = malloc (512);
-	dirp->dd_len = 512;
-
-	if (dirp->dd_buf == NULL) {
-		free (dirp);
-		close (fd);
-		return NULL;
-	}
-	dirp->dd_fd = fd;
-	dirp->dd_loc = 0;
-	dirp->dd_seek = 0;
-	/*
-	 * Set up seek point for rewinddir.
-	 */
-
-#ifdef HAVE_DD_LOCK
-	/* if we have a locking mechanism, initialize it */
-	__lock_init_recursive(dirp->dd_lock);
-#endif
-
-	return dirp;
-}
-
-#endif /* ! HAVE_OPENDIR */
+// #ifndef HAVE_OPENDIR
+//
+// /*
+//  * Copyright (c) 1983 Regents of the University of California.
+//  * All rights reserved.
+//  *
+//  * Redistribution and use in source and binary forms, with or without
+//  * modification, are permitted provided that the following conditions
+//  * are met:
+//  * 1. Redistributions of source code must retain the above copyright
+//  *    notice, this list of conditions and the following disclaimer.
+//  * 2. Redistributions in binary form must reproduce the above copyright
+//  *    notice, this list of conditions and the following disclaimer in the
+//  *    documentation and/or other materials provided with the distribution.
+//  * 3. All advertising materials mentioning features or use of this software
+//  *    must display the following acknowledgement:
+//  *	This product includes software developed by the University of
+//  *	California, Berkeley and its contributors.
+//  * 4. Neither the name of the University nor the names of its contributors
+//  *    may be used to endorse or promote products derived from this software
+//  *    without specific prior written permission.
+//  *
+//  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+//  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+//  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+//  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+//  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+//  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+//  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+//  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+//  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+//  * SUCH DAMAGE.
+//  */
+//
+// #if defined(LIBC_SCCS) && !defined(lint)
+// static char sccsid[] = "@(#)opendir.c	5.11 (Berkeley) 2/23/91";
+// #endif /* LIBC_SCCS and not lint */
+//
+// #include <dirent.h>
+// #include <fcntl.h>
+// #include <stdlib.h>
+// #include <unistd.h>
+// #include <sys/lock.h>
+//
+// /*
+//  * open a directory.
+//  */
+// DIR *
+// _DEFUN(opendir, (name),
+// 	const char *name)
+// {
+// 	register DIR *dirp;
+// 	register int fd;
+// 	int rc = 0;
+//
+// 	if ((fd = open(name, 0)) == -1)
+// 		return NULL;
+// #ifdef HAVE_FCNTL
+// 	rc = fcntl(fd, F_SETFD, 1);
+// #endif
+// 	if (rc == -1 ||
+// 	    (dirp = (DIR *)malloc(sizeof(DIR))) == NULL) {
+// 		close (fd);
+// 		return NULL;
+// 	}
+// 	/*
+// 	 * If CLSIZE is an exact multiple of DIRBLKSIZ, use a CLSIZE
+// 	 * buffer that it cluster boundary aligned.
+// 	 * Hopefully this can be a big win someday by allowing page trades
+// 	 * to user space to be done by getdirentries()
+// 	 */
+// 	dirp->dd_buf = malloc (512);
+// 	dirp->dd_len = 512;
+//
+// 	if (dirp->dd_buf == NULL) {
+// 		free (dirp);
+// 		close (fd);
+// 		return NULL;
+// 	}
+// 	dirp->dd_fd = fd;
+// 	dirp->dd_loc = 0;
+// 	dirp->dd_seek = 0;
+// 	/*
+// 	 * Set up seek point for rewinddir.
+// 	 */
+//
+// #ifdef HAVE_DD_LOCK
+// 	/* if we have a locking mechanism, initialize it */
+// 	__lock_init_recursive(dirp->dd_lock);
+// #endif
+//
+// 	return dirp;
+// }
+//
+// #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/readdir.c new/newlib/libc/posix/readdir.c
--- old/newlib/libc/posix/readdir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/readdir.c	2016-04-29 09:21:24.095384236 -0500
@@ -1,92 +1,92 @@
-#ifndef HAVE_OPENDIR
-
-/*
- * Copyright (c) 1983 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)readdir.c	5.7 (Berkeley) 6/1/90";
-#endif /* LIBC_SCCS and not lint */
-
-#include <dirent.h>
-
-extern int getdents (int fd, void *dp, int count);
-
-/*
- * get next entry in a directory.
- */
-struct dirent *
-_DEFUN(readdir, (dirp),
-       register DIR *dirp)
-{
-  register struct dirent *dp;
- 
-#ifdef HAVE_DD_LOCK
-  __lock_acquire_recursive(dirp->dd_lock);
-#endif
- 
-  for (;;) {
-    if (dirp->dd_loc == 0) {
-      dirp->dd_size = getdents (dirp->dd_fd,
-				dirp->dd_buf,
-				dirp->dd_len);
-      
-      if (dirp->dd_size <= 0) {
-#ifdef HAVE_DD_LOCK
-        __lock_release_recursive(dirp->dd_lock);
-#endif
-	return NULL;
-      }
-    }
-    if (dirp->dd_loc >= dirp->dd_size) {
-      dirp->dd_loc = 0;
-      continue;
-    }
-    dp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
-    if (dp->d_reclen <= 0 ||
-	dp->d_reclen > dirp->dd_len + 1 - dirp->dd_loc) {
-#ifdef HAVE_DD_LOCK
-      __lock_release_recursive(dirp->dd_lock);
-#endif
-      return NULL;
-    }
-    dirp->dd_loc += dp->d_reclen;
-    if (dp->d_ino == 0)
-      continue;
-#ifdef HAVE_DD_LOCK
-    __lock_release_recursive(dirp->dd_lock);
-#endif
-    return (dp);
-  }
-}
-
-#endif /* ! HAVE_OPENDIR */
+// #ifndef HAVE_OPENDIR
+//
+// /*
+//  * Copyright (c) 1983 Regents of the University of California.
+//  * All rights reserved.
+//  *
+//  * Redistribution and use in source and binary forms, with or without
+//  * modification, are permitted provided that the following conditions
+//  * are met:
+//  * 1. Redistributions of source code must retain the above copyright
+//  *    notice, this list of conditions and the following disclaimer.
+//  * 2. Redistributions in binary form must reproduce the above copyright
+//  *    notice, this list of conditions and the following disclaimer in the
+//  *    documentation and/or other materials provided with the distribution.
+//  * 3. All advertising materials mentioning features or use of this software
+//  *    must display the following acknowledgement:
+//  *	This product includes software developed by the University of
+//  *	California, Berkeley and its contributors.
+//  * 4. Neither the name of the University nor the names of its contributors
+//  *    may be used to endorse or promote products derived from this software
+//  *    without specific prior written permission.
+//  *
+//  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+//  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+//  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+//  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+//  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+//  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+//  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+//  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+//  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+//  * SUCH DAMAGE.
+//  */
+//
+// #if defined(LIBC_SCCS) && !defined(lint)
+// static char sccsid[] = "@(#)readdir.c	5.7 (Berkeley) 6/1/90";
+// #endif /* LIBC_SCCS and not lint */
+//
+// #include <dirent.h>
+//
+// extern int getdents (int fd, void *dp, int count);
+//
+// /*
+//  * get next entry in a directory.
+//  */
+// struct dirent *
+// _DEFUN(readdir, (dirp),
+//        register DIR *dirp)
+// {
+//   register struct dirent *dp;
+//
+// #ifdef HAVE_DD_LOCK
+//   __lock_acquire_recursive(dirp->dd_lock);
+// #endif
+//
+//   for (;;) {
+//     if (dirp->dd_loc == 0) {
+//       dirp->dd_size = getdents (dirp->dd_fd,
+// 				dirp->dd_buf,
+// 				dirp->dd_len);
+//
+//       if (dirp->dd_size <= 0) {
+// #ifdef HAVE_DD_LOCK
+//         __lock_release_recursive(dirp->dd_lock);
+// #endif
+// 	return NULL;
+//       }
+//     }
+//     if (dirp->dd_loc >= dirp->dd_size) {
+//       dirp->dd_loc = 0;
+//       continue;
+//     }
+//     dp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
+//     if (dp->d_reclen <= 0 ||
+// 	dp->d_reclen > dirp->dd_len + 1 - dirp->dd_loc) {
+// #ifdef HAVE_DD_LOCK
+//       __lock_release_recursive(dirp->dd_lock);
+// #endif
+//       return NULL;
+//     }
+//     dirp->dd_loc += dp->d_reclen;
+//     if (dp->d_ino == 0)
+//       continue;
+// #ifdef HAVE_DD_LOCK
+//     __lock_release_recursive(dirp->dd_lock);
+// #endif
+//     return (dp);
+//   }
+// }
+//
+// #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/readdir_r.c new/newlib/libc/posix/readdir_r.c
--- old/newlib/libc/posix/readdir_r.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/readdir_r.c	2016-04-29 09:21:24.099384271 -0500
@@ -1,105 +1,105 @@
-#ifndef HAVE_OPENDIR
-
-/*
- * Copyright (c) 1983 Regents of the University of California.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-/* this code is modified from readdir.c by Jeff Johnston, June 5, 2002 */
-
-#if defined(LIBC_SCCS) && !defined(lint)
-static char sccsid[] = "@(#)readdir.c	5.7 (Berkeley) 6/1/90";
-#endif /* LIBC_SCCS and not lint */
-
-#include <dirent.h>
-#include <errno.h>
-#include <string.h>
-#include <sys/param.h>
-
-extern int getdents (int fd, void *dp, int count);
-
-/*
- * get next entry in a directory using supplied dirent structure.
- */
-int
-_DEFUN(readdir_r, (dirp, dp, dpp),
-	register DIR *__restrict dirp _AND
-	struct dirent *__restrict dp _AND
-	struct dirent **__restrict dpp) {
-
-struct dirent *tmpdp;
- 
-#ifdef HAVE_DD_LOCK
-  __lock_acquire_recursive(dirp->dd_lock);
-#endif
- 
-  for (;;) {
-    if (dirp->dd_loc == 0) {
-      dirp->dd_size = getdents (dirp->dd_fd,
-				dirp->dd_buf,
-				dirp->dd_len);
-      
-      if (dirp->dd_size <= 0) {
-#ifdef HAVE_DD_LOCK
-        __lock_release_recursive(dirp->dd_lock);
-#endif
-        *dpp = NULL;
-        return dirp->dd_size == 0 ? 0 : errno;
-      }
-    }
-    if (dirp->dd_loc >= dirp->dd_size) {
-      dirp->dd_loc = 0;
-      continue;
-    }
-    tmpdp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
-
-    if (tmpdp->d_reclen <= 0 ||
-	tmpdp->d_reclen > dirp->dd_len + 1 - dirp->dd_loc) {
-#ifdef HAVE_DD_LOCK
-      __lock_release_recursive(dirp->dd_lock);
-#endif
-      *dpp = NULL;
-      return -1;
-    }
-    memcpy (dp, tmpdp, MIN (tmpdp->d_reclen, sizeof (struct dirent)));
-    
-    dirp->dd_loc += dp->d_reclen;
-    if (dp->d_ino == 0)
-      continue;
-#ifdef HAVE_DD_LOCK
-    __lock_release_recursive(dirp->dd_lock);
-#endif
-    *dpp = dp;
-    return 0;
-  }
-}
-
-#endif /* ! HAVE_OPENDIR */
+// #ifndef HAVE_OPENDIR
+//
+// /*
+//  * Copyright (c) 1983 Regents of the University of California.
+//  * All rights reserved.
+//  *
+//  * Redistribution and use in source and binary forms, with or without
+//  * modification, are permitted provided that the following conditions
+//  * are met:
+//  * 1. Redistributions of source code must retain the above copyright
+//  *    notice, this list of conditions and the following disclaimer.
+//  * 2. Redistributions in binary form must reproduce the above copyright
+//  *    notice, this list of conditions and the following disclaimer in the
+//  *    documentation and/or other materials provided with the distribution.
+//  * 3. All advertising materials mentioning features or use of this software
+//  *    must display the following acknowledgement:
+//  *	This product includes software developed by the University of
+//  *	California, Berkeley and its contributors.
+//  * 4. Neither the name of the University nor the names of its contributors
+//  *    may be used to endorse or promote products derived from this software
+//  *    without specific prior written permission.
+//  *
+//  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+//  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+//  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+//  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+//  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+//  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+//  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+//  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+//  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+//  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+//  * SUCH DAMAGE.
+//  */
+//
+// /* this code is modified from readdir.c by Jeff Johnston, June 5, 2002 */
+//
+// #if defined(LIBC_SCCS) && !defined(lint)
+// static char sccsid[] = "@(#)readdir.c	5.7 (Berkeley) 6/1/90";
+// #endif /* LIBC_SCCS and not lint */
+//
+// #include <dirent.h>
+// #include <errno.h>
+// #include <string.h>
+// #include <sys/param.h>
+//
+// extern int getdents (int fd, void *dp, int count);
+//
+// /*
+//  * get next entry in a directory using supplied dirent structure.
+//  */
+// int
+// _DEFUN(readdir_r, (dirp, dp, dpp),
+// 	register DIR *__restrict dirp _AND
+// 	struct dirent *__restrict dp _AND
+// 	struct dirent **__restrict dpp) {
+//
+// struct dirent *tmpdp;
+//
+// #ifdef HAVE_DD_LOCK
+//   __lock_acquire_recursive(dirp->dd_lock);
+// #endif
+//
+//   for (;;) {
+//     if (dirp->dd_loc == 0) {
+//       dirp->dd_size = getdents (dirp->dd_fd,
+// 				dirp->dd_buf,
+// 				dirp->dd_len);
+//
+//       if (dirp->dd_size <= 0) {
+// #ifdef HAVE_DD_LOCK
+//         __lock_release_recursive(dirp->dd_lock);
+// #endif
+//         *dpp = NULL;
+//         return dirp->dd_size == 0 ? 0 : errno;
+//       }
+//     }
+//     if (dirp->dd_loc >= dirp->dd_size) {
+//       dirp->dd_loc = 0;
+//       continue;
+//     }
+//     tmpdp = (struct dirent *)(dirp->dd_buf + dirp->dd_loc);
+//
+//     if (tmpdp->d_reclen <= 0 ||
+// 	tmpdp->d_reclen > dirp->dd_len + 1 - dirp->dd_loc) {
+// #ifdef HAVE_DD_LOCK
+//       __lock_release_recursive(dirp->dd_lock);
+// #endif
+//       *dpp = NULL;
+//       return -1;
+//     }
+//     memcpy (dp, tmpdp, MIN (tmpdp->d_reclen, sizeof (struct dirent)));
+//
+//     dirp->dd_loc += dp->d_reclen;
+//     if (dp->d_ino == 0)
+//       continue;
+// #ifdef HAVE_DD_LOCK
+//     __lock_release_recursive(dirp->dd_lock);
+// #endif
+//     *dpp = dp;
+//     return 0;
+//   }
+// }
+//
+// #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/rewinddir.c new/newlib/libc/posix/rewinddir.c
--- old/newlib/libc/posix/rewinddir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/rewinddir.c	2016-04-29 09:21:24.099384271 -0500
@@ -45,13 +45,13 @@ void
 _DEFUN(rewinddir, (dirp),
 	DIR *dirp)
 {
-#ifdef HAVE_DD_LOCK
-	__lock_acquire_recursive(dirp->dd_lock);
-#endif
-	_seekdir((dirp), 0L);
-#ifdef HAVE_DD_LOCK
-	__lock_release_recursive(dirp->dd_lock);
-#endif
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire_recursive(dirp->dd_lock);
+// #endif
+// 	_seekdir((dirp), 0L);
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release_recursive(dirp->dd_lock);
+// #endif
 }
 
 #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/scandir.c new/newlib/libc/posix/scandir.c
--- old/newlib/libc/posix/scandir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/scandir.c	2016-04-29 09:21:24.099384271 -0500
@@ -74,95 +74,95 @@ _DEFUN(scandir, (dirname, namelist, sele
 	int (*select) __P((const struct dirent *)) _AND
 	int (*dcomp) __P((const struct dirent **, const struct dirent **)))
 {
-	register struct dirent *d, *p, **names;
-	register size_t nitems;
-	struct stat stb;
-	long arraysz;
-	DIR *dirp;
-	int successful = 0;
-	int rc = 0;
-
-	dirp = NULL;
-	names = NULL;
-
-	if ((dirp = opendir(dirname)) == NULL)
-		return(-1);
-#ifdef HAVE_DD_LOCK
-	__lock_acquire_recursive(dirp->dd_lock);
-#endif
-	if (fstat(dirp->dd_fd, &stb) < 0)
-		goto cleanup;
-
-	/*
- 	 * If there were no directory entries, then bail.
- 	 */
-	if (stb.st_size == 0)
-		goto cleanup;
-
-	/*
-	 * estimate the array size by taking the size of the directory file
-	 * and dividing it by a multiple of the minimum size entry. 
-	 */
-	arraysz = (stb.st_size / 24);
-	names = (struct dirent **)malloc(arraysz * sizeof(struct dirent *));
-	if (names == NULL)
-		goto cleanup;
-
-	nitems = 0;
-	while ((d = readdir(dirp)) != NULL) {
-		if (select != NULL && !(*select)(d))
-			continue;	/* just selected names */
-		/*
-		 * Make a minimum size copy of the data
-		 */
-		p = (struct dirent *)malloc(DIRSIZ(d));
-		if (p == NULL)
-			goto cleanup;
-		p->d_ino = d->d_ino;
-		p->d_reclen = d->d_reclen;
-#ifdef _DIRENT_HAVE_D_NAMLEN
-		p->d_namlen = d->d_namlen;
-		bcopy(d->d_name, p->d_name, p->d_namlen + 1);
-#else
-               strcpy(p->d_name, d->d_name);
-#endif
-		/*
-		 * Check to make sure the array has space left and
-		 * realloc the maximum size.
-		 */
-		if (++nitems >= arraysz) {
-			if (fstat(dirp->dd_fd, &stb) < 0)
-				goto cleanup;
-			arraysz = stb.st_size / 12;
-			names = (struct dirent **)reallocf((char *)names,
-				arraysz * sizeof(struct dirent *));
-			if (names == NULL)
-				goto cleanup;
-		}
-		names[nitems-1] = p;
-	}
-	successful = 1;
-cleanup:
-	closedir(dirp);
-	if (successful) {
-		if (nitems && dcomp != NULL)
-			qsort(names, nitems, sizeof(struct dirent *), (void *)dcomp);
-		*namelist = names;
-		rc = nitems;
-	} else {  /* We were unsuccessful, clean up storage and return -1.  */
-		if ( names ) {
-			int i;
-			for (i=0; i < nitems; i++ )
-				free( names[i] );
-			free( names );
-		}
-		rc = -1;
-	}
-
-#ifdef HAVE_DD_LOCK
-	__lock_release_recursive(dirp->dd_lock);
-#endif
-	return(rc);
+// 	register struct dirent *d, *p, **names;
+// 	register size_t nitems;
+// 	struct stat stb;
+// 	long arraysz;
+// 	DIR *dirp;
+// 	int successful = 0;
+// 	int rc = 0;
+//
+// 	dirp = NULL;
+// 	names = NULL;
+//
+// 	if ((dirp = opendir(dirname)) == NULL)
+// 		return(-1);
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire_recursive(dirp->dd_lock);
+// #endif
+// 	if (fstat(dirp->dd_fd, &stb) < 0)
+// 		goto cleanup;
+//
+// 	/*
+//  	 * If there were no directory entries, then bail.
+//  	 */
+// 	if (stb.st_size == 0)
+// 		goto cleanup;
+//
+// 	/*
+// 	 * estimate the array size by taking the size of the directory file
+// 	 * and dividing it by a multiple of the minimum size entry.
+// 	 */
+// 	arraysz = (stb.st_size / 24);
+// 	names = (struct dirent **)malloc(arraysz * sizeof(struct dirent *));
+// 	if (names == NULL)
+// 		goto cleanup;
+//
+// 	nitems = 0;
+// 	while ((d = readdir(dirp)) != NULL) {
+// 		if (select != NULL && !(*select)(d))
+// 			continue;	/* just selected names */
+// 		/*
+// 		 * Make a minimum size copy of the data
+// 		 */
+// 		p = (struct dirent *)malloc(DIRSIZ(d));
+// 		if (p == NULL)
+// 			goto cleanup;
+// 		p->d_ino = d->d_ino;
+// 		p->d_reclen = d->d_reclen;
+// #ifdef _DIRENT_HAVE_D_NAMLEN
+// 		p->d_namlen = d->d_namlen;
+// 		bcopy(d->d_name, p->d_name, p->d_namlen + 1);
+// #else
+//                strcpy(p->d_name, d->d_name);
+// #endif
+// 		/*
+// 		 * Check to make sure the array has space left and
+// 		 * realloc the maximum size.
+// 		 */
+// 		if (++nitems >= arraysz) {
+// 			if (fstat(dirp->dd_fd, &stb) < 0)
+// 				goto cleanup;
+// 			arraysz = stb.st_size / 12;
+// 			names = (struct dirent **)reallocf((char *)names,
+// 				arraysz * sizeof(struct dirent *));
+// 			if (names == NULL)
+// 				goto cleanup;
+// 		}
+// 		names[nitems-1] = p;
+// 	}
+// 	successful = 1;
+// cleanup:
+// 	closedir(dirp);
+// 	if (successful) {
+// 		if (nitems && dcomp != NULL)
+// 			qsort(names, nitems, sizeof(struct dirent *), (void *)dcomp);
+// 		*namelist = names;
+// 		rc = nitems;
+// 	} else {  /* We were unsuccessful, clean up storage and return -1.  */
+// 		if ( names ) {
+// 			int i;
+// 			for (i=0; i < nitems; i++ )
+// 				free( names[i] );
+// 			free( names );
+// 		}
+// 		rc = -1;
+// 	}
+//
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release_recursive(dirp->dd_lock);
+// #endif
+// 	return(rc);
 }
 
 /*
diff -rupN old/newlib/libc/posix/seekdir.c new/newlib/libc/posix/seekdir.c
--- old/newlib/libc/posix/seekdir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/seekdir.c	2016-04-29 09:21:24.099384271 -0500
@@ -50,13 +50,13 @@ _DEFUN(seekdir, (dirp, loc),
 	DIR *dirp _AND
 	long loc)
 {
-#ifdef HAVE_DD_LOCK
-	__lock_acquire_recursive(dirp->dd_lock);
-#endif
-	_seekdir(dirp, loc);
-#ifdef HAVE_DD_LOCK
-	__lock_release_recursive(dirp->dd_lock);
-#endif
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire_recursive(dirp->dd_lock);
+// #endif
+// 	_seekdir(dirp, loc);
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release_recursive(dirp->dd_lock);
+// #endif
 }
 
 #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/sleep.c new/newlib/libc/posix/sleep.c
--- old/newlib/libc/posix/sleep.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/sleep.c	2016-04-29 09:21:24.099384271 -0500
@@ -1,22 +1,22 @@
-/* libc/posix/sleep.c - sleep function */
-
-/* Written 2000 by Werner Almesberger */
-
-#ifdef HAVE_NANOSLEEP
-
-#include <errno.h>
-#include <time.h>
-#include <unistd.h>
-
-unsigned sleep(unsigned seconds)
-{
-    struct timespec ts;
-
-    ts.tv_sec = seconds;
-    ts.tv_nsec = 0;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
-    return -1;
-}
-
-#endif
+// /* libc/posix/sleep.c - sleep function */
+//
+// /* Written 2000 by Werner Almesberger */
+//
+// #ifdef HAVE_NANOSLEEP
+//
+// #include <errno.h>
+// #include <time.h>
+// #include <unistd.h>
+//
+// unsigned sleep(unsigned seconds)
+// {
+//     struct timespec ts;
+//
+//     ts.tv_sec = seconds;
+//     ts.tv_nsec = 0;
+//     if (!nanosleep(&ts,&ts)) return 0;
+//     if (errno == EINTR) return ts.tv_sec;
+//     return -1;
+// }
+//
+// #endif
diff -rupN old/newlib/libc/posix/telldir.c new/newlib/libc/posix/telldir.c
--- old/newlib/libc/posix/telldir.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/telldir.c	2016-04-29 09:21:24.099384271 -0500
@@ -52,7 +52,7 @@ static char sccsid[] = "@(#)telldir.c	5.
 
 /*
  * One of these structures is malloced to describe the current directory
- * position each time telldir is called. It records the current magic 
+ * position each time telldir is called. It records the current magic
  * cookie returned by getdirentries and the offset within the buffer
  * associated with that return value.
  */
@@ -84,28 +84,28 @@ long
 _DEFUN(telldir, (dirp),
        DIR *dirp)
 {
-	register int index;
-	register struct ddloc *lp;
-
-	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL)
-		return (-1);
-
-#ifdef HAVE_DD_LOCK
-	__lock_acquire_recursive(dirp->dd_lock);
-	__lock_acquire(dd_hash_lock);
-#endif
-	index = dd_loccnt++;
-	lp->loc_index = index;
-	lp->loc_seek = dirp->dd_seek;
-	lp->loc_loc = dirp->dd_loc;
-	lp->loc_dirp = dirp;
-	lp->loc_next = dd_hash[LOCHASH(index)];
-	dd_hash[LOCHASH(index)] = lp;
-#ifdef HAVE_DD_LOCK
-	__lock_release(dd_hash_lock);
-	__lock_release_recursive(dirp->dd_lock);
-#endif
-	return (index);
+// 	register int index;
+// 	register struct ddloc *lp;
+//
+// 	if ((lp = (struct ddloc *)malloc(sizeof(struct ddloc))) == NULL)
+// 		return (-1);
+//
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire_recursive(dirp->dd_lock);
+// 	__lock_acquire(dd_hash_lock);
+// #endif
+// 	index = dd_loccnt++;
+// 	lp->loc_index = index;
+// 	lp->loc_seek = dirp->dd_seek;
+// 	lp->loc_loc = dirp->dd_loc;
+// 	lp->loc_dirp = dirp;
+// 	lp->loc_next = dd_hash[LOCHASH(index)];
+// 	dd_hash[LOCHASH(index)] = lp;
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release(dd_hash_lock);
+// 	__lock_release_recursive(dirp->dd_lock);
+// #endif
+// 	return (index);
 }
 
 #endif /* !_ELIX_LEVEL || _ELIX_LEVEL >= 2 */
@@ -119,52 +119,52 @@ _DEFUN(_seekdir, (dirp, loc),
 	register DIR *dirp _AND
 	long loc)
 {
-	register struct ddloc *lp;
-	register struct ddloc **prevlp;
-	struct dirent *dp;
-
-#ifdef HAVE_DD_LOCK
-	__lock_acquire(dd_hash_lock);
-#endif
-	if (loc != 0) {
-		prevlp = &dd_hash[LOCHASH(loc)];
-		lp = *prevlp;
-		while (lp != NULL) {
-			if (lp->loc_index == loc)
-				break;
-			prevlp = &lp->loc_next;
-			lp = lp->loc_next;
-		}
-		if (lp == NULL) {
-#ifdef HAVE_DD_LOCK
-			__lock_release(dd_hash_lock);
-#endif
-			return;
-		}
-		if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
-			goto found;
-		(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
-		dirp->dd_seek = lp->loc_seek;
-		dirp->dd_loc = 0;
-		while (dirp->dd_loc < lp->loc_loc) {
-			dp = readdir(dirp);
-			if (dp == NULL)
-				break;
-		}
-found:
-#ifdef SINGLEUSE
-		*prevlp = lp->loc_next;
-		free((caddr_t)lp);
-#endif
-	} else {
-		// loc 0 means rewinding
-		(void) lseek(dirp->dd_fd, 0, 0);
-		dirp->dd_seek = 0;
-		dirp->dd_loc = 0;
-	}
-#ifdef HAVE_DD_LOCK
-	__lock_release(dd_hash_lock);
-#endif
+// 	register struct ddloc *lp;
+// 	register struct ddloc **prevlp;
+// 	struct dirent *dp;
+//
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire(dd_hash_lock);
+// #endif
+// 	if (loc != 0) {
+// 		prevlp = &dd_hash[LOCHASH(loc)];
+// 		lp = *prevlp;
+// 		while (lp != NULL) {
+// 			if (lp->loc_index == loc)
+// 				break;
+// 			prevlp = &lp->loc_next;
+// 			lp = lp->loc_next;
+// 		}
+// 		if (lp == NULL) {
+// #ifdef HAVE_DD_LOCK
+// 			__lock_release(dd_hash_lock);
+// #endif
+// 			return;
+// 		}
+// 		if (lp->loc_loc == dirp->dd_loc && lp->loc_seek == dirp->dd_seek)
+// 			goto found;
+// 		(void) lseek(dirp->dd_fd, lp->loc_seek, 0);
+// 		dirp->dd_seek = lp->loc_seek;
+// 		dirp->dd_loc = 0;
+// 		while (dirp->dd_loc < lp->loc_loc) {
+// 			dp = readdir(dirp);
+// 			if (dp == NULL)
+// 				break;
+// 		}
+// found:
+// #ifdef SINGLEUSE
+// 		*prevlp = lp->loc_next;
+// 		free((caddr_t)lp);
+// #endif
+// 	} else {
+// 		// loc 0 means rewinding
+// 		(void) lseek(dirp->dd_fd, 0, 0);
+// 		dirp->dd_seek = 0;
+// 		dirp->dd_loc = 0;
+// 	}
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release(dd_hash_lock);
+// #endif
 }
 
 /* clean out any hash entries from a closed directory */
@@ -172,36 +172,36 @@ void
 _DEFUN(_cleanupdir, (dirp),
 	register DIR *dirp)
 {
-	int i;
-
-#ifdef HAVE_DD_LOCK
-	__lock_acquire(dd_hash_lock);
-#endif
-	for (i = 0; i < NDIRHASH; ++i) {
-		struct ddloc head;
-		register struct ddloc *lp;
-		register struct ddloc *prevlp;
-
-		lp = dd_hash[i];
-		head.loc_next = lp;
-		prevlp = &head;
-		while (lp != NULL) {
-			struct ddloc *nextlp;
-
-			nextlp = lp->loc_next;
-			if (lp->loc_dirp == dirp) {
-				prevlp->loc_next = nextlp;
-				free((caddr_t)lp);
-			}
-			else
-				prevlp = lp;
-			lp = nextlp;
-		}
-		dd_hash[i] = head.loc_next;
-	}
-#ifdef HAVE_DD_LOCK
-	__lock_release(dd_hash_lock);
-#endif
+// 	int i;
+//
+// #ifdef HAVE_DD_LOCK
+// 	__lock_acquire(dd_hash_lock);
+// #endif
+// 	for (i = 0; i < NDIRHASH; ++i) {
+// 		struct ddloc head;
+// 		register struct ddloc *lp;
+// 		register struct ddloc *prevlp;
+//
+// 		lp = dd_hash[i];
+// 		head.loc_next = lp;
+// 		prevlp = &head;
+// 		while (lp != NULL) {
+// 			struct ddloc *nextlp;
+//
+// 			nextlp = lp->loc_next;
+// 			if (lp->loc_dirp == dirp) {
+// 				prevlp->loc_next = nextlp;
+// 				free((caddr_t)lp);
+// 			}
+// 			else
+// 				prevlp = lp;
+// 			lp = nextlp;
+// 		}
+// 		dd_hash[i] = head.loc_next;
+// 	}
+// #ifdef HAVE_DD_LOCK
+// 	__lock_release(dd_hash_lock);
+// #endif
 
 }
 #endif /* ! HAVE_OPENDIR */
diff -rupN old/newlib/libc/posix/usleep.c new/newlib/libc/posix/usleep.c
--- old/newlib/libc/posix/usleep.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/posix/usleep.c	2016-04-29 09:21:24.099384271 -0500
@@ -1,22 +1,22 @@
-/* libc/posix/usleep.c - usleep function */
-
-/* Written 2002 by Jeff Johnston */
-
-#ifdef HAVE_NANOSLEEP
-
-#include <errno.h>
-#include <time.h>
-#include <unistd.h>
-
-int usleep(useconds_t useconds)
-{
-    struct timespec ts;
-
-    ts.tv_sec = (long int)useconds / 1000000;
-    ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
-    if (!nanosleep(&ts,&ts)) return 0;
-    if (errno == EINTR) return ts.tv_sec;
-    return -1;
-}
-
-#endif
+// /* libc/posix/usleep.c - usleep function */
+//
+// /* Written 2002 by Jeff Johnston */
+//
+// #ifdef HAVE_NANOSLEEP
+//
+// #include <errno.h>
+// #include <time.h>
+// #include <unistd.h>
+//
+// int usleep(useconds_t useconds)
+// {
+//     struct timespec ts;
+//
+//     ts.tv_sec = (long int)useconds / 1000000;
+//     ts.tv_nsec = ((long int)useconds % 1000000) * 1000;
+//     if (!nanosleep(&ts,&ts)) return 0;
+//     if (errno == EINTR) return ts.tv_sec;
+//     return -1;
+// }
+//
+// #endif
diff -rupN old/newlib/libc/stdio/fseeko.c new/newlib/libc/stdio/fseeko.c
--- old/newlib/libc/stdio/fseeko.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/stdio/fseeko.c	2016-04-29 09:21:24.099384271 -0500
@@ -158,202 +158,6 @@ _DEFUN(_fseeko_r, (ptr, fp, offset, when
       return EOF;
     }
 
-  /*
-   * Change any SEEK_CUR to SEEK_SET, and check `whence' argument.
-   * After this, whence is either SEEK_SET or SEEK_END.
-   */
-
-  switch (whence)
-    {
-    case SEEK_CUR:
-      /*
-       * In order to seek relative to the current stream offset,
-       * we have to first find the current stream offset a la
-       * ftell (see ftell for details).
-       */
-      _fflush_r (ptr, fp);   /* may adjust seek offset on append stream */
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
-	  if (curoff == -1L)
-	    {
-	      _newlib_flockfile_exit (fp);
-	      return EOF;
-	    }
-	}
-      if (fp->_flags & __SRD)
-	{
-	  curoff -= fp->_r;
-	  if (HASUB (fp))
-	    curoff -= fp->_ur;
-	}
-      else if (fp->_flags & __SWR && fp->_p != NULL)
-	curoff += fp->_p - fp->_bf._base;
-
-      offset += curoff;
-      whence = SEEK_SET;
-      havepos = 1;
-      break;
-
-    case SEEK_SET:
-    case SEEK_END:
-      havepos = 0;
-      break;
-
-    default:
-      ptr->_errno = EINVAL;
-      _newlib_flockfile_exit (fp);
-      return (EOF);
-    }
-
-  /*
-   * Can only optimise if:
-   *	reading (and not reading-and-writing);
-   *	not unbuffered; and
-   *	this is a `regular' Unix file (and hence seekfn==__sseek).
-   * We must check __NBF first, because it is possible to have __NBF
-   * and __SOPT both set.
-   */
-
-  if (fp->_bf._base == NULL)
-    __smakebuf_r (ptr, fp);
-
-#ifdef _FSEEK_OPTIMIZATION
-  if (fp->_flags & (__SWR | __SRW | __SNBF | __SNPT))
-    goto dumb;
-  if ((fp->_flags & __SOPT) == 0)
-    {
-      if (seekfn != __sseek
-	  || fp->_file < 0
-#ifdef __USE_INTERNAL_STAT64
-	  || _fstat64_r (ptr, fp->_file, &st)
-#else
-	  || _fstat_r (ptr, fp->_file, &st)
-#endif
-	  || (st.st_mode & S_IFMT) != S_IFREG)
-	{
-	  fp->_flags |= __SNPT;
-	  goto dumb;
-	}
-#ifdef	HAVE_BLKSIZE
-      fp->_blksize = st.st_blksize;
-#else
-      fp->_blksize = 1024;
-#endif
-      fp->_flags |= __SOPT;
-    }
-
-  /*
-   * We are reading; we can try to optimise.
-   * Figure out where we are going and where we are now.
-   */
-
-  if (whence == SEEK_SET)
-    target = offset;
-  else
-    {
-#ifdef __USE_INTERNAL_STAT64
-      if (_fstat64_r (ptr, fp->_file, &st))
-#else
-      if (_fstat_r (ptr, fp->_file, &st))
-#endif
-	goto dumb;
-      target = st.st_size + offset;
-    }
-
-  if (!havepos)
-    {
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, 0L, SEEK_CUR);
-	  if (curoff == POS_ERR)
-	    goto dumb;
-	}
-      curoff -= fp->_r;
-      if (HASUB (fp))
-	curoff -= fp->_ur;
-    }
-
-  /*
-   * Compute the number of bytes in the input buffer (pretending
-   * that any ungetc() input has been discarded).  Adjust current
-   * offset backwards by this count so that it represents the
-   * file offset for the first byte in the current input buffer.
-   */
-
-  if (HASUB (fp))
-    {
-      curoff += fp->_r;       /* kill off ungetc */
-      n = fp->_up - fp->_bf._base;
-      curoff -= n;
-      n += fp->_ur;
-    }
-  else
-    {
-      n = fp->_p - fp->_bf._base;
-      curoff -= n;
-      n += fp->_r;
-    }
-
-  /*
-   * If the target offset is within the current buffer,
-   * simply adjust the pointers, clear EOF, undo ungetc(),
-   * and return.
-   */
-
-  if (target >= curoff && target < curoff + n)
-    {
-      register int o = target - curoff;
-
-      fp->_p = fp->_bf._base + o;
-      fp->_r = n - o;
-      if (HASUB (fp))
-	FREEUB (ptr, fp);
-      fp->_flags &= ~__SEOF;
-      memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-      _newlib_flockfile_exit (fp);
-      return 0;
-    }
-
-  /*
-   * The place we want to get to is not within the current buffer,
-   * but we can still be kind to the kernel copyout mechanism.
-   * By aligning the file offset to a block boundary, we can let
-   * the kernel use the VM hardware to map pages instead of
-   * copying bytes laboriously.  Using a block boundary also
-   * ensures that we only read one block, rather than two.
-   */
-
-  curoff = target & ~(fp->_blksize - 1);
-  if (seekfn (ptr, fp->_cookie, curoff, SEEK_SET) == POS_ERR)
-    goto dumb;
-  fp->_r = 0;
-  fp->_p = fp->_bf._base;
-  if (HASUB (fp))
-    FREEUB (ptr, fp);
-  fp->_flags &= ~__SEOF;
-  n = target - curoff;
-  if (n)
-    {
-      if (__srefill_r (ptr, fp) || fp->_r < n)
-	goto dumb;
-      fp->_p += n;
-      fp->_r -= n;
-    }
-  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-  _newlib_flockfile_exit (fp);
-  return 0;
-
-  /*
-   * We get here if we cannot optimise the seek ... just
-   * do it.  Allow the seek function to change fp->_bf._base.
-   */
-#endif
-
 dumb:
   if (_fflush_r (ptr, fp)
       || seekfn (ptr, fp->_cookie, offset, whence) == POS_ERR)
diff -rupN old/newlib/libc/stdlib/mallocr.c new/newlib/libc/stdlib/mallocr.c
--- old/newlib/libc/stdlib/mallocr.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/stdlib/mallocr.c	2016-04-29 09:21:24.103384306 -0500
@@ -609,8 +609,11 @@ do {
   operating system immediately after a free().
 */
 
+#define HAVE_MMAP 0
+#define HAVE_MREMAP 0
+
 #ifndef HAVE_MMAP
-#define HAVE_MMAP 1
+#define HAVE_MMAP 0
 #endif
 
 /*
diff -rupN old/newlib/libc/sys/configure new/newlib/libc/sys/configure
--- old/newlib/libc/sys/configure	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/sys/configure	2016-04-29 09:21:24.107384341 -0500
@@ -809,6 +809,7 @@ sysvi386
 sysvnecv70
 tic80
 tirtos
+toyos
 w65
 z8ksim'
 
@@ -11852,6 +11853,8 @@ subdirs="$subdirs a29khif"
  ;;
 	tirtos) subdirs="$subdirs tirtos"
  ;;
+	toyos) subdirs="$subdirs toyos"
+ ;;
 	w65) subdirs="$subdirs w65"
  ;;
 	z8ksim) subdirs="$subdirs z8ksim"
diff -rupN old/newlib/libc/sys/configure.in new/newlib/libc/sys/configure.in
--- old/newlib/libc/sys/configure.in	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/sys/configure.in	2016-04-29 09:21:24.107384341 -0500
@@ -46,6 +46,7 @@ if test -n "${sys_dir}"; then
 	sysvnecv70) AC_CONFIG_SUBDIRS(sysvnecv70) ;;
 	tic80) AC_CONFIG_SUBDIRS(tic80) ;;
 	tirtos) AC_CONFIG_SUBDIRS(tirtos) ;;
+	toyos) AC_CONFIG_SUBDIRS(toyos) ;;
 	w65) AC_CONFIG_SUBDIRS(w65) ;;
 	z8ksim) AC_CONFIG_SUBDIRS(z8ksim) ;;
   esac;
