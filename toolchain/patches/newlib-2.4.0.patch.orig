diff -rupN old/config.sub new/config.sub
--- old/config.sub	2016-03-29 16:33:42.000000000 -0500
+++ new/config.sub	2016-04-24 22:01:50.638639563 -0500
@@ -1391,7 +1391,7 @@ case $os in
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
+	      | -uxpv* | -beos* | -mpeix* | -toyos* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
diff -rupN old/newlib/configure.host new/newlib/configure.host
--- old/newlib/configure.host	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/configure.host	2016-04-24 22:04:05.999637907 -0500
@@ -448,6 +448,10 @@ case "${host}" in
   h8500-*-elf*)
 	sys_dir=h8500hms
 	;;
+  i[34567]86-*-toyos*)
+	sys_dir=toyos
+   posix_dir=posix
+	;;
   i[34567]86-*-rdos*)
 	sys_dir=rdos
 	newlib_cflags="${newlib_cflags} -DMISSING_SYSCALL_NAMES"
@@ -568,6 +571,9 @@ esac
 # THIS TABLE IS ALPHA SORTED.  KEEP IT THAT WAY.

 case "${host}" in
+  *-*-toyos)
+	newlib_cflags="${newlib_cflags} -fPIC -DSIGNAL_PROVIDED -DMISSING_SYSCALL_NAMES -DMALLOC_PROVIDED"
+	;;
   *-*-cygwin*)
 	test -z "$cygwin_srcdir" && cygwin_srcdir=`cd ${srcdir}/../winsup/cygwin; pwd`
 	export cygwin_srcdir
diff -rupN old/newlib/libc/include/sys/_intsup.h new/newlib/libc/include/sys/_intsup.h
--- old/newlib/libc/include/sys/_intsup.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/_intsup.h	2016-04-24 22:29:06.858522099 -0500
@@ -79,14 +79,15 @@
 #elif (__INTPTR_TYPE__ == 1 || __INTPTR_TYPE__ == 3)
 #define _INTPTR_EQ_SHORT
 #else
-#error "Unable to determine type definition of intptr_t"
+// #error "Unable to determine type definition of intptr_t"
+#define _INTPTR_EQ_INT
 #endif
 #if (__INT32_TYPE__ == 4 || __INT32_TYPE__ == 6)
 #define _INT32_EQ_LONG
 #elif __INT32_TYPE__ == 2
 /* Nothing to define because int32_t is safe to print as an int. */
 #else
-#error "Unable to determine type definition of int32_t"
+// #error "Unable to determine type definition of int32_t"
 #endif

 #if (__INT8_TYPE__ == 0)
diff -rupN old/newlib/libc/include/sys/stat.h new/newlib/libc/include/sys/stat.h
--- old/newlib/libc/include/sys/stat.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/stat.h	2016-04-24 22:05:27.952239624 -0500
@@ -152,8 +152,8 @@ int	_EXFUN(mkfifo,( const char *__path,
 int	_EXFUN(stat,( const char *__restrict __path, struct stat *__restrict __sbuf ));
 mode_t	_EXFUN(umask,( mode_t __mask ));

-#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(lstat,( const char *__restrict __path, struct stat *__restrict __buf ));
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
 int	_EXFUN(mknod,( const char *__path, mode_t __mode, dev_t __dev ));
 #endif

diff -rupN old/newlib/libc/include/sys/utime.h new/newlib/libc/include/sys/utime.h
--- old/newlib/libc/include/sys/utime.h	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/include/sys/utime.h	2016-04-24 22:06:23.880649282 -0500
@@ -15,6 +15,8 @@ struct utimbuf
   time_t modtime;
 };

+int utime(const char *filename, const struct utimbuf *times);
+
 #ifdef __cplusplus
 };
 #endif
diff -rupN old/newlib/libc/stdio/fseeko.c new/newlib/libc/stdio/fseeko.c
--- old/newlib/libc/stdio/fseeko.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/stdio/fseeko.c	2016-04-24 22:09:05.237827491 -0500
@@ -158,202 +158,6 @@ _DEFUN(_fseeko_r, (ptr, fp, offset, when
       return EOF;
     }

-  /*
-   * Change any SEEK_CUR to SEEK_SET, and check `whence' argument.
-   * After this, whence is either SEEK_SET or SEEK_END.
-   */
-
-  switch (whence)
-    {
-    case SEEK_CUR:
-      /*
-       * In order to seek relative to the current stream offset,
-       * we have to first find the current stream offset a la
-       * ftell (see ftell for details).
-       */
-      _fflush_r (ptr, fp);   /* may adjust seek offset on append stream */
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, (_fpos_t) 0, SEEK_CUR);
-	  if (curoff == -1L)
-	    {
-	      _newlib_flockfile_exit (fp);
-	      return EOF;
-	    }
-	}
-      if (fp->_flags & __SRD)
-	{
-	  curoff -= fp->_r;
-	  if (HASUB (fp))
-	    curoff -= fp->_ur;
-	}
-      else if (fp->_flags & __SWR && fp->_p != NULL)
-	curoff += fp->_p - fp->_bf._base;
-
-      offset += curoff;
-      whence = SEEK_SET;
-      havepos = 1;
-      break;
-
-    case SEEK_SET:
-    case SEEK_END:
-      havepos = 0;
-      break;
-
-    default:
-      ptr->_errno = EINVAL;
-      _newlib_flockfile_exit (fp);
-      return (EOF);
-    }
-
-  /*
-   * Can only optimise if:
-   *	reading (and not reading-and-writing);
-   *	not unbuffered; and
-   *	this is a `regular' Unix file (and hence seekfn==__sseek).
-   * We must check __NBF first, because it is possible to have __NBF
-   * and __SOPT both set.
-   */
-
-  if (fp->_bf._base == NULL)
-    __smakebuf_r (ptr, fp);
-
-#ifdef _FSEEK_OPTIMIZATION
-  if (fp->_flags & (__SWR | __SRW | __SNBF | __SNPT))
-    goto dumb;
-  if ((fp->_flags & __SOPT) == 0)
-    {
-      if (seekfn != __sseek
-	  || fp->_file < 0
-#ifdef __USE_INTERNAL_STAT64
-	  || _fstat64_r (ptr, fp->_file, &st)
-#else
-	  || _fstat_r (ptr, fp->_file, &st)
-#endif
-	  || (st.st_mode & S_IFMT) != S_IFREG)
-	{
-	  fp->_flags |= __SNPT;
-	  goto dumb;
-	}
-#ifdef	HAVE_BLKSIZE
-      fp->_blksize = st.st_blksize;
-#else
-      fp->_blksize = 1024;
-#endif
-      fp->_flags |= __SOPT;
-    }
-
-  /*
-   * We are reading; we can try to optimise.
-   * Figure out where we are going and where we are now.
-   */
-
-  if (whence == SEEK_SET)
-    target = offset;
-  else
-    {
-#ifdef __USE_INTERNAL_STAT64
-      if (_fstat64_r (ptr, fp->_file, &st))
-#else
-      if (_fstat_r (ptr, fp->_file, &st))
-#endif
-	goto dumb;
-      target = st.st_size + offset;
-    }
-
-  if (!havepos)
-    {
-      if (fp->_flags & __SOFF)
-	curoff = fp->_offset;
-      else
-	{
-	  curoff = seekfn (ptr, fp->_cookie, 0L, SEEK_CUR);
-	  if (curoff == POS_ERR)
-	    goto dumb;
-	}
-      curoff -= fp->_r;
-      if (HASUB (fp))
-	curoff -= fp->_ur;
-    }
-
-  /*
-   * Compute the number of bytes in the input buffer (pretending
-   * that any ungetc() input has been discarded).  Adjust current
-   * offset backwards by this count so that it represents the
-   * file offset for the first byte in the current input buffer.
-   */
-
-  if (HASUB (fp))
-    {
-      curoff += fp->_r;       /* kill off ungetc */
-      n = fp->_up - fp->_bf._base;
-      curoff -= n;
-      n += fp->_ur;
-    }
-  else
-    {
-      n = fp->_p - fp->_bf._base;
-      curoff -= n;
-      n += fp->_r;
-    }
-
-  /*
-   * If the target offset is within the current buffer,
-   * simply adjust the pointers, clear EOF, undo ungetc(),
-   * and return.
-   */
-
-  if (target >= curoff && target < curoff + n)
-    {
-      register int o = target - curoff;
-
-      fp->_p = fp->_bf._base + o;
-      fp->_r = n - o;
-      if (HASUB (fp))
-	FREEUB (ptr, fp);
-      fp->_flags &= ~__SEOF;
-      memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-      _newlib_flockfile_exit (fp);
-      return 0;
-    }
-
-  /*
-   * The place we want to get to is not within the current buffer,
-   * but we can still be kind to the kernel copyout mechanism.
-   * By aligning the file offset to a block boundary, we can let
-   * the kernel use the VM hardware to map pages instead of
-   * copying bytes laboriously.  Using a block boundary also
-   * ensures that we only read one block, rather than two.
-   */
-
-  curoff = target & ~(fp->_blksize - 1);
-  if (seekfn (ptr, fp->_cookie, curoff, SEEK_SET) == POS_ERR)
-    goto dumb;
-  fp->_r = 0;
-  fp->_p = fp->_bf._base;
-  if (HASUB (fp))
-    FREEUB (ptr, fp);
-  fp->_flags &= ~__SEOF;
-  n = target - curoff;
-  if (n)
-    {
-      if (__srefill_r (ptr, fp) || fp->_r < n)
-	goto dumb;
-      fp->_p += n;
-      fp->_r -= n;
-    }
-  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
-  _newlib_flockfile_exit (fp);
-  return 0;
-
-  /*
-   * We get here if we cannot optimise the seek ... just
-   * do it.  Allow the seek function to change fp->_bf._base.
-   */
-#endif
-
 dumb:
   if (_fflush_r (ptr, fp)
       || seekfn (ptr, fp->_cookie, offset, whence) == POS_ERR)
diff -rupN old/newlib/libc/stdlib/mallocr.c new/newlib/libc/stdlib/mallocr.c
--- old/newlib/libc/stdlib/mallocr.c	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/stdlib/mallocr.c	2016-04-24 22:10:19.062365039 -0500
@@ -609,8 +609,11 @@ do {
   operating system immediately after a free().
 */

+#define HAVE_MMAP 0
+#define HAVE_MREMAP 0
+
 #ifndef HAVE_MMAP
-#define HAVE_MMAP 1
+#define HAVE_MMAP 0
 #endif

 /*
diff -rupN old/newlib/libc/sys/configure new/newlib/libc/sys/configure
--- old/newlib/libc/sys/configure	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/sys/configure	2016-04-24 22:11:16.530782950 -0500
@@ -809,6 +809,7 @@ sysvi386
 sysvnecv70
 tic80
 tirtos
+toyos
 w65
 z8ksim'

@@ -11852,6 +11853,8 @@ subdirs="$subdirs a29khif"
  ;;
 	tirtos) subdirs="$subdirs tirtos"
  ;;
+	toyos) subdirs="$subdirs toyos"
+ ;;
 	w65) subdirs="$subdirs w65"
  ;;
 	z8ksim) subdirs="$subdirs z8ksim"
diff -rupN old/newlib/libc/sys/configure.in new/newlib/libc/sys/configure.in
--- old/newlib/libc/sys/configure.in	2016-03-29 16:33:42.000000000 -0500
+++ new/newlib/libc/sys/configure.in	2016-04-24 22:11:50.383028925 -0500
@@ -46,6 +46,7 @@ if test -n "${sys_dir}"; then
 	sysvnecv70) AC_CONFIG_SUBDIRS(sysvnecv70) ;;
 	tic80) AC_CONFIG_SUBDIRS(tic80) ;;
 	tirtos) AC_CONFIG_SUBDIRS(tirtos) ;;
+	toyos) AC_CONFIG_SUBDIRS(toyos) ;;
 	w65) AC_CONFIG_SUBDIRS(w65) ;;
 	z8ksim) AC_CONFIG_SUBDIRS(z8ksim) ;;
   esac;
